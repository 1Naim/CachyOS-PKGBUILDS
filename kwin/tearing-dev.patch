From 4abe4b8147f93cf9d5f88def75ac317adf62602c Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Sat, 6 Jul 2024 14:50:17 +0200
Subject: [PATCH] backends/drm: support tearing with atomic modesetting

Whenever tearing is desired, this does an atomic test to figure out if the current
configuration can do tearing - if not, the backend just transparently falls back to
synchronous commits.
As the kernel (as of Linux 6.9) rejects all commits that are both async and modify
more than the primary plane FB_ID property, this disables the cursor plane and
IN_FENCE_FD usage, to make it more likely for the atomic commit to succeed.
Once these restrictions are loosened, these checks can be removed as well.
---
 src/backends/drm/drm_commit.cpp        | 21 +++++++++++++++++----
 src/backends/drm/drm_commit.h          |  1 +
 src/backends/drm/drm_commit_thread.cpp |  7 +++++--
 src/backends/drm/drm_commit_thread.h   |  1 +
 src/backends/drm/drm_gpu.cpp           |  6 +++++-
 src/backends/drm/drm_output.cpp        |  9 ++++++++-
 src/backends/drm/drm_output.h          |  2 ++
 7 files changed, 39 insertions(+), 8 deletions(-)

diff --git a/src/backends/drm/drm_commit.cpp b/src/backends/drm/drm_commit.cpp
index 963e4f9fed6..fa5989734e3 100644
--- a/src/backends/drm/drm_commit.cpp
+++ b/src/backends/drm/drm_commit.cpp
@@ -62,8 +62,8 @@ void DrmAtomicCommit::addBuffer(DrmPlane *plane, const std::shared_ptr<DrmFrameb
     addProperty(plane->fbId, buffer ? buffer->framebufferId() : 0);
     m_buffers[plane] = buffer;
     m_frames[plane] = frame;
-    // atomic commits with IN_FENCE_FD fail with NVidia
-    if (plane->inFenceFd.isValid() && !plane->gpu()->isNVidia()) {
+    // atomic commits with IN_FENCE_FD fail with NVidia and (as of kernel 6.9) with tearing
+    if (plane->inFenceFd.isValid() && !plane->gpu()->isNVidia() && !isTearing()) {
         addProperty(plane->inFenceFd, buffer ? buffer->syncFd().get() : -1);
     }
     m_planes.emplace(plane);
@@ -89,7 +89,11 @@ void DrmAtomicCommit::setPresentationMode(PresentationMode mode)
 
 bool DrmAtomicCommit::test()
 {
-    return doCommit(DRM_MODE_ATOMIC_TEST_ONLY | DRM_MODE_ATOMIC_NONBLOCK);
+    uint32_t flags = DRM_MODE_ATOMIC_TEST_ONLY | DRM_MODE_ATOMIC_NONBLOCK;
+    if (isTearing()) {
+        flags |= DRM_MODE_PAGE_FLIP_ASYNC;
+    }
+    return doCommit(flags);
 }
 
 bool DrmAtomicCommit::testAllowModeset()
@@ -99,7 +103,11 @@ bool DrmAtomicCommit::testAllowModeset()
 
 bool DrmAtomicCommit::commit()
 {
-    return doCommit(DRM_MODE_ATOMIC_NONBLOCK | DRM_MODE_PAGE_FLIP_EVENT);
+    uint32_t flags = DRM_MODE_ATOMIC_NONBLOCK | DRM_MODE_PAGE_FLIP_EVENT;
+    if (isTearing()) {
+        flags |= DRM_MODE_PAGE_FLIP_ASYNC;
+    }
+    return doCommit(flags);
 }
 
 bool DrmAtomicCommit::commitModeset()
@@ -235,6 +243,11 @@ bool DrmAtomicCommit::isReadyFor(std::chrono::steady_clock::time_point pageflipT
     return (!m_targetPageflipTime || pageflipTarget + s_pageflipSlop >= *m_targetPageflipTime) && areBuffersReadable();
 }
 
+bool DrmAtomicCommit::isTearing() const
+{
+    return m_mode == PresentationMode::Async || m_mode == PresentationMode::AdaptiveAsync;
+}
+
 DrmLegacyCommit::DrmLegacyCommit(DrmPipeline *pipeline, const std::shared_ptr<DrmFramebuffer> &buffer, const std::shared_ptr<OutputFrame> &frame)
     : DrmCommit(pipeline->gpu())
     , m_pipeline(pipeline)
diff --git a/src/backends/drm/drm_commit.h b/src/backends/drm/drm_commit.h
index 8469f5f789f..34c14477fac 100644
--- a/src/backends/drm/drm_commit.h
+++ b/src/backends/drm/drm_commit.h
@@ -84,6 +84,7 @@ public:
 
     std::optional<std::chrono::steady_clock::time_point> targetPageflipTime() const;
     bool isReadyFor(std::chrono::steady_clock::time_point pageflipTarget) const;
+    bool isTearing() const;
 
 private:
     bool doCommit(uint32_t flags);
diff --git a/src/backends/drm/drm_commit_thread.cpp b/src/backends/drm/drm_commit_thread.cpp
index b765dd72843..9d30433c237 100644
--- a/src/backends/drm/drm_commit_thread.cpp
+++ b/src/backends/drm/drm_commit_thread.cpp
@@ -63,7 +63,7 @@ DrmCommitThread::DrmCommitThread(DrmGpu *gpu, const QString &name)
             optimizeCommits(m_targetPageflipTime);
             if (!m_commits.front()->isReadyFor(m_targetPageflipTime)) {
                 // no commit is ready yet, reschedule
-                if (m_vrr) {
+                if (m_vrr || m_tearing) {
                     m_targetPageflipTime += 50us;
                 } else {
                     m_targetPageflipTime += m_minVblankInterval;
@@ -108,6 +108,7 @@ void DrmCommitThread::submit()
     const bool success = commit->commit();
     if (success) {
         m_vrr = vrr.value_or(m_vrr);
+        m_tearing = commit->isTearing();
         m_committed = std::move(commit);
         m_commits.erase(m_commits.begin());
     } else {
@@ -267,7 +268,9 @@ void DrmCommitThread::addCommit(std::unique_ptr<DrmAtomicCommit> &&commit)
     std::unique_lock lock(m_mutex);
     m_commits.push_back(std::move(commit));
     const auto now = std::chrono::steady_clock::now();
-    if (m_vrr && now >= m_lastPageflip + m_minVblankInterval) {
+    if (m_tearing) {
+        m_targetPageflipTime = now;
+    } else if (m_vrr && now >= m_lastPageflip + m_minVblankInterval) {
         m_targetPageflipTime = now;
     } else {
         m_targetPageflipTime = estimateNextVblank(now);
diff --git a/src/backends/drm/drm_commit_thread.h b/src/backends/drm/drm_commit_thread.h
index 159628f0680..7ada259d63b 100644
--- a/src/backends/drm/drm_commit_thread.h
+++ b/src/backends/drm/drm_commit_thread.h
@@ -59,6 +59,7 @@ private:
     std::chrono::nanoseconds m_minVblankInterval;
     std::vector<std::unique_ptr<DrmAtomicCommit>> m_commitsToDelete;
     bool m_vrr = false;
+    bool m_tearing = false;
     std::chrono::nanoseconds m_safetyMargin{0};
 };
 
diff --git a/src/backends/drm/drm_gpu.cpp b/src/backends/drm/drm_gpu.cpp
index 39b14856ce6..5e782d9706b 100644
--- a/src/backends/drm/drm_gpu.cpp
+++ b/src/backends/drm/drm_gpu.cpp
@@ -41,6 +41,9 @@
 #ifndef DRM_CLIENT_CAP_CURSOR_PLANE_HOTSPOT
 #define DRM_CLIENT_CAP_CURSOR_PLANE_HOTSPOT 6
 #endif
+#ifndef DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP
+#define DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP 0x15
+#endif
 
 namespace KWin
 {
@@ -90,8 +93,9 @@ DrmGpu::DrmGpu(DrmBackend *backend, int fd, std::unique_ptr<DrmDevice> &&device)
     initDrmResources();
 
     if (m_atomicModeSetting == false) {
-        // only supported with legacy
         m_asyncPageflipSupported = drmGetCap(fd, DRM_CAP_ASYNC_PAGE_FLIP, &capability) == 0 && capability == 1;
+    } else {
+        m_asyncPageflipSupported = drmGetCap(fd, DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP, &capability) == 0 && capability == 1;
     }
 }
 
diff --git a/src/backends/drm/drm_output.cpp b/src/backends/drm/drm_output.cpp
index 7561c899168..51ec775c1c7 100644
--- a/src/backends/drm/drm_output.cpp
+++ b/src/backends/drm/drm_output.cpp
@@ -155,6 +155,12 @@ DrmLease *DrmOutput::lease() const
 
 bool DrmOutput::updateCursorLayer()
 {
+    const bool tearingDesired = m_desiredPresentationMode == PresentationMode::Async || m_desiredPresentationMode == PresentationMode::AdaptiveAsync;
+    if (m_pipeline->gpu()->atomicModeSetting() && tearingDesired && m_pipeline->cursorLayer() && m_pipeline->cursorLayer()->isEnabled()) {
+        // The kernel rejects async commits that change anything but the primary plane FB_ID
+        // This disables the hardware cursor, so it doesn't interfere with that
+        return false;
+    }
     return m_pipeline->updateCursor();
 }
 
@@ -281,7 +287,8 @@ void DrmOutput::updateDpmsMode(DpmsMode dpmsMode)
 
 bool DrmOutput::present(const std::shared_ptr<OutputFrame> &frame)
 {
-    const bool needsModeset = gpu()->needsModeset();
+    m_desiredPresentationMode = frame->presentationMode();
+    const bool needsModeset = m_gpu->needsModeset();
     bool success;
     if (needsModeset) {
         m_pipeline->setPresentationMode(PresentationMode::VSync);
diff --git a/src/backends/drm/drm_output.h b/src/backends/drm/drm_output.h
index 8d424147cf2..acc2a7a8f28 100644
--- a/src/backends/drm/drm_output.h
+++ b/src/backends/drm/drm_output.h
@@ -78,6 +78,8 @@ private:
 
     QVector3D m_channelFactors = {1, 1, 1};
     bool m_channelFactorsNeedShaderFallback = false;
+
+    PresentationMode m_desiredPresentationMode = PresentationMode::VSync;
 };
 
 }
-- 
GitLab

From 8d944cb6473875e23bda9ee04df6141f8f907153 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Sat, 6 Jul 2024 15:14:25 +0200
Subject: [PATCH] backends/drm: test direct scanout with the same code as
 presentation

This means that we prefer direct scanout over a specific presentation mode (tearing),
which usually just means we first engage direct scanout and program the relevant
properties, and then switch to tearing afterwards.
It also removes a hack for direct scanout with legacy, and is one step less for
implementing overlay plane support.
---
 src/backends/drm/drm_egl_backend.cpp          |  4 +--
 src/backends/drm/drm_egl_backend.h            |  2 +-
 src/backends/drm/drm_egl_layer.cpp            |  9 +++----
 src/backends/drm/drm_egl_layer.h              |  2 +-
 src/backends/drm/drm_output.cpp               |  7 ++++-
 src/backends/drm/drm_pipeline.cpp             | 27 -------------------
 src/backends/drm/drm_pipeline.h               |  2 --
 src/backends/drm/drm_qpainter_backend.cpp     |  4 +--
 src/backends/drm/drm_qpainter_backend.h       |  2 +-
 src/backends/drm/drm_virtual_egl_layer.cpp    |  2 +-
 src/backends/drm/drm_virtual_egl_layer.h      |  2 +-
 src/backends/virtual/virtual_egl_backend.cpp  |  3 ++-
 src/backends/virtual/virtual_egl_backend.h    |  2 +-
 .../virtual/virtual_qpainter_backend.cpp      |  3 ++-
 .../virtual/virtual_qpainter_backend.h        |  2 +-
 src/backends/wayland/wayland_egl_backend.cpp  |  5 ++--
 src/backends/wayland/wayland_egl_backend.h    |  4 +--
 .../wayland/wayland_qpainter_backend.cpp      |  3 ++-
 .../wayland/wayland_qpainter_backend.h        |  2 +-
 .../standalone/x11_standalone_egl_backend.cpp |  3 ++-
 .../standalone/x11_standalone_egl_backend.h   |  2 +-
 .../standalone/x11_standalone_glx_backend.cpp |  3 ++-
 .../standalone/x11_standalone_glx_backend.h   |  2 +-
 .../x11/windowed/x11_windowed_egl_backend.cpp |  3 ++-
 .../x11/windowed/x11_windowed_egl_backend.h   |  2 +-
 .../x11_windowed_qpainter_backend.cpp         |  3 ++-
 .../windowed/x11_windowed_qpainter_backend.h  |  2 +-
 src/compositor_wayland.cpp                    | 13 ++++++---
 src/core/outputlayer.cpp                      |  6 ++---
 src/core/outputlayer.h                        |  9 ++++---
 src/core/renderbackend.cpp                    | 10 +++++++
 src/core/renderbackend.h                      |  6 ++++-
 32 files changed, 77 insertions(+), 74 deletions(-)

diff --git a/src/backends/drm/drm_egl_backend.cpp b/src/backends/drm/drm_egl_backend.cpp
index 369009f8b6e..9e040ee9934 100644
--- a/src/backends/drm/drm_egl_backend.cpp
+++ b/src/backends/drm/drm_egl_backend.cpp
@@ -141,9 +141,9 @@ DrmDevice *EglGbmBackend::drmDevice() const
     return gpu()->drmDevice();
 }
 
-void EglGbmBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool EglGbmBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
-    static_cast<DrmAbstractOutput *>(output)->present(frame);
+    return static_cast<DrmAbstractOutput *>(output)->present(frame);
 }
 
 OutputLayer *EglGbmBackend::primaryLayer(Output *output)
diff --git a/src/backends/drm/drm_egl_backend.h b/src/backends/drm/drm_egl_backend.h
index dab2ccb9216..f016644b4f6 100644
--- a/src/backends/drm/drm_egl_backend.h
+++ b/src/backends/drm/drm_egl_backend.h
@@ -46,7 +46,7 @@ public:
 
     DrmDevice *drmDevice() const override;
 
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     OutputLayer *primaryLayer(Output *output) override;
     OutputLayer *cursorLayer(Output *output) override;
 
diff --git a/src/backends/drm/drm_egl_layer.cpp b/src/backends/drm/drm_egl_layer.cpp
index 52d97c7667a..fd3f575c58a 100644
--- a/src/backends/drm/drm_egl_layer.cpp
+++ b/src/backends/drm/drm_egl_layer.cpp
@@ -83,7 +83,7 @@ ColorDescription EglGbmLayer::colorDescription() const
     return m_surface.colorDescription();
 }
 
-bool EglGbmLayer::doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
+bool EglGbmLayer::doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
 {
     static bool valid;
     static const bool directScanoutDisabled = qEnvironmentVariableIntValue("KWIN_DRM_NO_DIRECT_SCANOUT", &valid) == 1 && valid;
@@ -113,13 +113,10 @@ bool EglGbmLayer::doAttemptScanout(GraphicsBuffer *buffer, const ColorDescriptio
         return false;
     }
     m_scanoutBuffer = m_pipeline->gpu()->importBuffer(buffer, FileDescriptor{});
-    if (m_scanoutBuffer && m_pipeline->testScanout(frame)) {
+    if (m_scanoutBuffer) {
         m_surface.forgetDamage(); // TODO: Use absolute frame sequence numbers for indexing the DamageJournal. It's more flexible and less error-prone
-        return true;
-    } else {
-        m_scanoutBuffer.reset();
-        return false;
     }
+    return m_scanoutBuffer != nullptr;
 }
 
 std::shared_ptr<DrmFramebuffer> EglGbmLayer::currentBuffer() const
diff --git a/src/backends/drm/drm_egl_layer.h b/src/backends/drm/drm_egl_layer.h
index 9acb4373a45..333658beca6 100644
--- a/src/backends/drm/drm_egl_layer.h
+++ b/src/backends/drm/drm_egl_layer.h
@@ -39,7 +39,7 @@ public:
     std::optional<QSize> fixedSize() const override;
 
 private:
-    bool doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame) override;
+    bool doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame) override;
 
     std::shared_ptr<DrmFramebuffer> m_scanoutBuffer;
 
diff --git a/src/backends/drm/drm_output.cpp b/src/backends/drm/drm_output.cpp
index 51ec775c1c7..dbcede940bb 100644
--- a/src/backends/drm/drm_output.cpp
+++ b/src/backends/drm/drm_output.cpp
@@ -291,6 +291,11 @@ bool DrmOutput::present(const std::shared_ptr<OutputFrame> &frame)
     const bool needsModeset = m_gpu->needsModeset();
     bool success;
     if (needsModeset) {
+        if (frame->isDirectScanout()) {
+            // don't do modesets with direct scanout, it might lead to locking
+            // the hardware to some buffer format we can't switch away from
+            return false;
+        }
         m_pipeline->setPresentationMode(PresentationMode::VSync);
         m_pipeline->setContentType(DrmConnector::DrmContentType::Graphics);
         success = m_pipeline->maybeModeset(frame);
@@ -303,7 +308,7 @@ bool DrmOutput::present(const std::shared_ptr<OutputFrame> &frame)
             err = m_pipeline->present(frame);
         }
         success = err == DrmPipeline::Error::None;
-        if (err == DrmPipeline::Error::InvalidArguments) {
+        if (!frame->isDirectScanout() && err == DrmPipeline::Error::InvalidArguments) {
             QTimer::singleShot(0, m_gpu->platform(), &DrmBackend::updateOutputs);
         }
     }
diff --git a/src/backends/drm/drm_pipeline.cpp b/src/backends/drm/drm_pipeline.cpp
index 957d115a524..274420bd0ca 100644
--- a/src/backends/drm/drm_pipeline.cpp
+++ b/src/backends/drm/drm_pipeline.cpp
@@ -51,28 +51,6 @@ DrmPipeline::~DrmPipeline()
     }
 }
 
-bool DrmPipeline::testScanout(const std::shared_ptr<OutputFrame> &frame)
-{
-    if (gpu()->needsModeset()) {
-        return false;
-    }
-    if (gpu()->atomicModeSetting()) {
-        return DrmPipeline::commitPipelinesAtomic({this}, CommitMode::Test, frame, {}) == Error::None;
-    } else {
-        if (m_primaryLayer->currentBuffer()->buffer()->size() != m_pending.mode->size()) {
-            // scaling isn't supported with the legacy API
-            return false;
-        }
-        // no other way to test than to do it.
-        // As we only have a maximum of one test per scanout cycle, this is fine
-        const bool ret = presentLegacy(frame) == Error::None;
-        if (ret) {
-            m_didLegacyScanoutHack = true;
-        }
-        return ret;
-    }
-}
-
 DrmPipeline::Error DrmPipeline::present(const std::shared_ptr<OutputFrame> &frame)
 {
     Q_ASSERT(m_pending.crtc);
@@ -93,11 +71,6 @@ DrmPipeline::Error DrmPipeline::present(const std::shared_ptr<OutputFrame> &fram
         m_commitThread->addCommit(std::move(primaryPlaneUpdate));
         return Error::None;
     } else {
-        if (m_didLegacyScanoutHack) {
-            // already presented
-            m_didLegacyScanoutHack = false;
-            return Error::None;
-        }
         return presentLegacy(frame);
     }
 }
diff --git a/src/backends/drm/drm_pipeline.h b/src/backends/drm/drm_pipeline.h
index 3664522f3e9..568c13756af 100644
--- a/src/backends/drm/drm_pipeline.h
+++ b/src/backends/drm/drm_pipeline.h
@@ -71,7 +71,6 @@ public:
      * if the test fails, there is a guarantee for no lasting changes
      */
     Error present(const std::shared_ptr<OutputFrame> &frame);
-    bool testScanout(const std::shared_ptr<OutputFrame> &frame);
     bool maybeModeset(const std::shared_ptr<OutputFrame> &frame);
     void forceLegacyModeset();
 
@@ -166,7 +165,6 @@ private:
     DrmConnector *m_connector = nullptr;
 
     bool m_modesetPresentPending = false;
-    bool m_didLegacyScanoutHack = false;
     std::shared_ptr<DrmGammaRamp> m_currentLegacyGamma;
 
     struct State
diff --git a/src/backends/drm/drm_qpainter_backend.cpp b/src/backends/drm/drm_qpainter_backend.cpp
index 0d45143b449..235038f0b84 100644
--- a/src/backends/drm/drm_qpainter_backend.cpp
+++ b/src/backends/drm/drm_qpainter_backend.cpp
@@ -37,9 +37,9 @@ DrmDevice *DrmQPainterBackend::drmDevice() const
     return m_backend->primaryGpu()->drmDevice();
 }
 
-void DrmQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool DrmQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
-    static_cast<DrmAbstractOutput *>(output)->present(frame);
+    return static_cast<DrmAbstractOutput *>(output)->present(frame);
 }
 
 OutputLayer *DrmQPainterBackend::primaryLayer(Output *output)
diff --git a/src/backends/drm/drm_qpainter_backend.h b/src/backends/drm/drm_qpainter_backend.h
index 904fa097ab8..a40fa68183e 100644
--- a/src/backends/drm/drm_qpainter_backend.h
+++ b/src/backends/drm/drm_qpainter_backend.h
@@ -30,7 +30,7 @@ public:
 
     DrmDevice *drmDevice() const override;
 
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     OutputLayer *primaryLayer(Output *output) override;
     OutputLayer *cursorLayer(Output *output) override;
 
diff --git a/src/backends/drm/drm_virtual_egl_layer.cpp b/src/backends/drm/drm_virtual_egl_layer.cpp
index 4d2aa046a5d..7ba9476752f 100644
--- a/src/backends/drm/drm_virtual_egl_layer.cpp
+++ b/src/backends/drm/drm_virtual_egl_layer.cpp
@@ -133,7 +133,7 @@ std::shared_ptr<GLTexture> VirtualEglGbmLayer::texture() const
     return nullptr;
 }
 
-bool VirtualEglGbmLayer::doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
+bool VirtualEglGbmLayer::doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
 {
     static bool valid;
     static const bool directScanoutDisabled = qEnvironmentVariableIntValue("KWIN_DRM_NO_DIRECT_SCANOUT", &valid) == 1 && valid;
diff --git a/src/backends/drm/drm_virtual_egl_layer.h b/src/backends/drm/drm_virtual_egl_layer.h
index b8cb2a40f27..8cdaca6e2db 100644
--- a/src/backends/drm/drm_virtual_egl_layer.h
+++ b/src/backends/drm/drm_virtual_egl_layer.h
@@ -44,7 +44,7 @@ public:
     const ColorDescription &colorDescription() const;
 
 private:
-    bool doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame) override;
+    bool doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame) override;
     std::shared_ptr<EglSwapchain> createGbmSwapchain() const;
     bool doesGbmSwapchainFit(EglSwapchain *swapchain) const;
 
diff --git a/src/backends/virtual/virtual_egl_backend.cpp b/src/backends/virtual/virtual_egl_backend.cpp
index 4cf6b31bc5b..fe34cc6edef 100644
--- a/src/backends/virtual/virtual_egl_backend.cpp
+++ b/src/backends/virtual/virtual_egl_backend.cpp
@@ -178,9 +178,10 @@ OutputLayer *VirtualEglBackend::primaryLayer(Output *output)
     return m_outputs[output].get();
 }
 
-void VirtualEglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool VirtualEglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     static_cast<VirtualOutput *>(output)->present(frame);
+    return true;
 }
 
 std::pair<std::shared_ptr<KWin::GLTexture>, ColorDescription> VirtualEglBackend::textureForOutput(Output *output) const
diff --git a/src/backends/virtual/virtual_egl_backend.h b/src/backends/virtual/virtual_egl_backend.h
index ec71500a1b9..7a4380d97b2 100644
--- a/src/backends/virtual/virtual_egl_backend.h
+++ b/src/backends/virtual/virtual_egl_backend.h
@@ -57,7 +57,7 @@ public:
     std::unique_ptr<SurfaceTexture> createSurfaceTextureWayland(SurfacePixmap *pixmap) override;
     std::pair<std::shared_ptr<KWin::GLTexture>, ColorDescription> textureForOutput(Output *output) const override;
     OutputLayer *primaryLayer(Output *output) override;
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     void init() override;
 
     VirtualBackend *backend() const;
diff --git a/src/backends/virtual/virtual_qpainter_backend.cpp b/src/backends/virtual/virtual_qpainter_backend.cpp
index 940a555e7c9..cdc02368cef 100644
--- a/src/backends/virtual/virtual_qpainter_backend.cpp
+++ b/src/backends/virtual/virtual_qpainter_backend.cpp
@@ -100,9 +100,10 @@ GraphicsBufferAllocator *VirtualQPainterBackend::graphicsBufferAllocator() const
     return m_allocator.get();
 }
 
-void VirtualQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool VirtualQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     static_cast<VirtualOutput *>(output)->present(frame);
+    return true;
 }
 
 VirtualQPainterLayer *VirtualQPainterBackend::primaryLayer(Output *output)
diff --git a/src/backends/virtual/virtual_qpainter_backend.h b/src/backends/virtual/virtual_qpainter_backend.h
index 22a0be7c37e..4eab5e1ebdb 100644
--- a/src/backends/virtual/virtual_qpainter_backend.h
+++ b/src/backends/virtual/virtual_qpainter_backend.h
@@ -55,7 +55,7 @@ public:
 
     GraphicsBufferAllocator *graphicsBufferAllocator() const;
 
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     VirtualQPainterLayer *primaryLayer(Output *output) override;
 
 private:
diff --git a/src/backends/wayland/wayland_egl_backend.cpp b/src/backends/wayland/wayland_egl_backend.cpp
index ce6b96a1283..f05b36ff63f 100644
--- a/src/backends/wayland/wayland_egl_backend.cpp
+++ b/src/backends/wayland/wayland_egl_backend.cpp
@@ -111,7 +111,7 @@ bool WaylandEglPrimaryLayer::doEndFrame(const QRegion &renderedRegion, const QRe
     return true;
 }
 
-bool WaylandEglPrimaryLayer::doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
+bool WaylandEglPrimaryLayer::doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
 {
     Q_ASSERT(!m_presentationBuffer);
     // TODO use viewporter to relax this check
@@ -347,11 +347,12 @@ std::unique_ptr<SurfaceTexture> WaylandEglBackend::createSurfaceTextureWayland(S
     return std::make_unique<BasicEGLSurfaceTextureWayland>(this, pixmap);
 }
 
-void WaylandEglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool WaylandEglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     m_outputs[output].primaryLayer->present();
     static_cast<WaylandOutput *>(output)->setPendingFrame(frame);
     Q_EMIT static_cast<WaylandOutput *>(output)->outputChange(frame->damage());
+    return true;
 }
 
 OutputLayer *WaylandEglBackend::primaryLayer(Output *output)
diff --git a/src/backends/wayland/wayland_egl_backend.h b/src/backends/wayland/wayland_egl_backend.h
index be255c0b1c0..52fbf073a54 100644
--- a/src/backends/wayland/wayland_egl_backend.h
+++ b/src/backends/wayland/wayland_egl_backend.h
@@ -44,7 +44,7 @@ public:
 
     std::optional<OutputLayerBeginFrameInfo> doBeginFrame() override;
     bool doEndFrame(const QRegion &renderedRegion, const QRegion &damagedRegion, OutputFrame *frame) override;
-    bool doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame) override;
+    bool doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame) override;
     DrmDevice *scanoutDevice() const override;
     QHash<uint32_t, QList<uint64_t>> supportedDrmFormats() const override;
 
@@ -104,7 +104,7 @@ public:
     std::unique_ptr<SurfaceTexture> createSurfaceTextureWayland(SurfacePixmap *pixmap) override;
 
     void init() override;
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     OutputLayer *primaryLayer(Output *output) override;
     OutputLayer *cursorLayer(Output *output) override;
 
diff --git a/src/backends/wayland/wayland_qpainter_backend.cpp b/src/backends/wayland/wayland_qpainter_backend.cpp
index ae544e95038..63cd209e852 100644
--- a/src/backends/wayland/wayland_qpainter_backend.cpp
+++ b/src/backends/wayland/wayland_qpainter_backend.cpp
@@ -178,10 +178,11 @@ GraphicsBufferAllocator *WaylandQPainterBackend::graphicsBufferAllocator() const
     return m_allocator.get();
 }
 
-void WaylandQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool WaylandQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     m_outputs[output].primaryLayer->present();
     static_cast<WaylandOutput *>(output)->setPendingFrame(frame);
+    return true;
 }
 
 OutputLayer *WaylandQPainterBackend::primaryLayer(Output *output)
diff --git a/src/backends/wayland/wayland_qpainter_backend.h b/src/backends/wayland/wayland_qpainter_backend.h
index 88c45fa1ff3..5f83223e833 100644
--- a/src/backends/wayland/wayland_qpainter_backend.h
+++ b/src/backends/wayland/wayland_qpainter_backend.h
@@ -87,7 +87,7 @@ public:
 
     GraphicsBufferAllocator *graphicsBufferAllocator() const;
 
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     OutputLayer *primaryLayer(Output *output) override;
     OutputLayer *cursorLayer(Output *output) override;
 
diff --git a/src/backends/x11/standalone/x11_standalone_egl_backend.cpp b/src/backends/x11/standalone/x11_standalone_egl_backend.cpp
index 5c980532383..00a4fd7f69d 100644
--- a/src/backends/x11/standalone/x11_standalone_egl_backend.cpp
+++ b/src/backends/x11/standalone/x11_standalone_egl_backend.cpp
@@ -386,7 +386,7 @@ void EglBackend::endFrame(const QRegion &renderedRegion, const QRegion &damagedR
     m_lastRenderedRegion = renderedRegion;
 }
 
-void EglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool EglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     m_frame = frame;
     // Start the software vsync monitor. There is no any reliable way to determine when
@@ -409,6 +409,7 @@ void EglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &fra
     if (overlayWindow() && overlayWindow()->window()) { // show the window only after the first pass,
         overlayWindow()->show(); // since that pass may take long
     }
+    return true;
 }
 
 void EglBackend::presentSurface(EGLSurface surface, const QRegion &damage, const QRect &screenGeometry)
diff --git a/src/backends/x11/standalone/x11_standalone_egl_backend.h b/src/backends/x11/standalone/x11_standalone_egl_backend.h
index bd32548607f..eba301a4785 100644
--- a/src/backends/x11/standalone/x11_standalone_egl_backend.h
+++ b/src/backends/x11/standalone/x11_standalone_egl_backend.h
@@ -56,7 +56,7 @@ public:
     std::unique_ptr<SurfaceTexture> createSurfaceTextureX11(SurfacePixmapX11 *texture) override;
     OutputLayerBeginFrameInfo beginFrame();
     void endFrame(const QRegion &renderedRegion, const QRegion &damagedRegion, OutputFrame *frame);
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     OverlayWindow *overlayWindow() const override;
     OutputLayer *primaryLayer(Output *output) override;
     EglDisplay *eglDisplayObject() const override;
diff --git a/src/backends/x11/standalone/x11_standalone_glx_backend.cpp b/src/backends/x11/standalone/x11_standalone_glx_backend.cpp
index 6f4f6b185d5..89097a4428d 100644
--- a/src/backends/x11/standalone/x11_standalone_glx_backend.cpp
+++ b/src/backends/x11/standalone/x11_standalone_glx_backend.cpp
@@ -686,7 +686,7 @@ void GlxBackend::endFrame(const QRegion &renderedRegion, const QRegion &damagedR
     m_lastRenderedRegion = renderedRegion;
 }
 
-void GlxBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool GlxBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     m_frame = frame;
     // If the GLX_INTEL_swap_event extension is not used for getting presentation feedback,
@@ -710,6 +710,7 @@ void GlxBackend::present(Output *output, const std::shared_ptr<OutputFrame> &fra
     if (overlayWindow()->window()) { // show the window only after the first pass,
         overlayWindow()->show(); // since that pass may take long
     }
+    return true;
 }
 
 void GlxBackend::vblank(std::chrono::nanoseconds timestamp)
diff --git a/src/backends/x11/standalone/x11_standalone_glx_backend.h b/src/backends/x11/standalone/x11_standalone_glx_backend.h
index 3b45ba19b89..50baaf8d30c 100644
--- a/src/backends/x11/standalone/x11_standalone_glx_backend.h
+++ b/src/backends/x11/standalone/x11_standalone_glx_backend.h
@@ -85,7 +85,7 @@ public:
     std::unique_ptr<SurfaceTexture> createSurfaceTextureX11(SurfacePixmapX11 *pixmap) override;
     OutputLayerBeginFrameInfo doBeginFrame();
     void endFrame(const QRegion &renderedRegion, const QRegion &damagedRegion, OutputFrame *frame);
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     bool makeCurrent() override;
     void doneCurrent() override;
     OpenGlContext *openglContext() const override;
diff --git a/src/backends/x11/windowed/x11_windowed_egl_backend.cpp b/src/backends/x11/windowed/x11_windowed_egl_backend.cpp
index de5528189c0..820107633ab 100644
--- a/src/backends/x11/windowed/x11_windowed_egl_backend.cpp
+++ b/src/backends/x11/windowed/x11_windowed_egl_backend.cpp
@@ -265,11 +265,12 @@ void X11WindowedEglBackend::init()
     }
 }
 
-void X11WindowedEglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool X11WindowedEglBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     m_outputs[output].primaryLayer->present();
     Q_EMIT static_cast<X11WindowedOutput *>(output)->outputChange(frame->damage());
     static_cast<X11WindowedOutput *>(output)->framePending(frame);
+    return true;
 }
 
 OutputLayer *X11WindowedEglBackend::primaryLayer(Output *output)
diff --git a/src/backends/x11/windowed/x11_windowed_egl_backend.h b/src/backends/x11/windowed/x11_windowed_egl_backend.h
index 2eed97295e6..a9af0dfecee 100644
--- a/src/backends/x11/windowed/x11_windowed_egl_backend.h
+++ b/src/backends/x11/windowed/x11_windowed_egl_backend.h
@@ -82,7 +82,7 @@ public:
     std::pair<std::shared_ptr<GLTexture>, ColorDescription> textureForOutput(Output *output) const override;
     void init() override;
     void endFrame(Output *output, const QRegion &renderedRegion, const QRegion &damagedRegion);
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     OutputLayer *primaryLayer(Output *output) override;
     OutputLayer *cursorLayer(Output *output) override;
 
diff --git a/src/backends/x11/windowed/x11_windowed_qpainter_backend.cpp b/src/backends/x11/windowed/x11_windowed_qpainter_backend.cpp
index 32b4a0ff49b..d17da15d88a 100644
--- a/src/backends/x11/windowed/x11_windowed_qpainter_backend.cpp
+++ b/src/backends/x11/windowed/x11_windowed_qpainter_backend.cpp
@@ -181,10 +181,11 @@ GraphicsBufferAllocator *X11WindowedQPainterBackend::graphicsBufferAllocator() c
     return m_allocator.get();
 }
 
-void X11WindowedQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
+bool X11WindowedQPainterBackend::present(Output *output, const std::shared_ptr<OutputFrame> &frame)
 {
     m_outputs[output].primaryLayer->present();
     static_cast<X11WindowedOutput *>(output)->framePending(frame);
+    return true;
 }
 
 OutputLayer *X11WindowedQPainterBackend::primaryLayer(Output *output)
diff --git a/src/backends/x11/windowed/x11_windowed_qpainter_backend.h b/src/backends/x11/windowed/x11_windowed_qpainter_backend.h
index c235b6f6ad7..dc14051bfaf 100644
--- a/src/backends/x11/windowed/x11_windowed_qpainter_backend.h
+++ b/src/backends/x11/windowed/x11_windowed_qpainter_backend.h
@@ -76,7 +76,7 @@ public:
 
     GraphicsBufferAllocator *graphicsBufferAllocator() const;
 
-    void present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
+    bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) override;
     OutputLayer *primaryLayer(Output *output) override;
     OutputLayer *cursorLayer(Output *output) override;
 
diff --git a/src/compositor_wayland.cpp b/src/compositor_wayland.cpp
index 691d9a5326b..8cf486e6c4e 100644
--- a/src/compositor_wayland.cpp
+++ b/src/compositor_wayland.cpp
@@ -291,6 +291,7 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
 
     renderLoop->prepareNewFrame();
     auto frame = std::make_shared<OutputFrame>(renderLoop, std::chrono::nanoseconds(1'000'000'000'000 / output->refreshRate()));
+    bool directScanout = false;
 
     if (primaryLayer->needsRepaint() || superLayer->needsRepaint()) {
         renderLoop->beginPaint();
@@ -313,7 +314,6 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
             frame->setPresentationMode(tearing ? PresentationMode::Async : PresentationMode::VSync);
         }
 
-        bool directScanout = false;
         if (const auto scanoutCandidate = superLayer->delegate()->scanoutCandidate()) {
             const auto sublayers = superLayer->sublayers();
             const bool scanoutPossible = std::none_of(sublayers.begin(), sublayers.end(), [](RenderLayer *sublayer) {
@@ -321,7 +321,12 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
             });
             if (scanoutPossible) {
                 primaryLayer->setTargetRect(centerBuffer(output->transform().map(scanoutCandidate->size()), output->modeSize()));
-                directScanout = primaryLayer->attemptScanout(scanoutCandidate, frame);
+                directScanout = primaryLayer->importScanoutBuffer(scanoutCandidate, frame);
+                if (directScanout) {
+                    frame->setDirectScanout(true);
+                    directScanout &= m_backend->present(output, frame);
+                    frame->setDirectScanout(directScanout);
+                }
             }
         } else {
             primaryLayer->notifyNoScanoutCandidate();
@@ -342,7 +347,9 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
         postPaintPass(superLayer);
     }
 
-    m_backend->present(output, frame);
+    if (!directScanout) {
+        m_backend->present(output, frame);
+    }
 
     framePass(superLayer, frame.get());
 
diff --git a/src/core/outputlayer.cpp b/src/core/outputlayer.cpp
index 5a0329fe5fc..349a68e2181 100644
--- a/src/core/outputlayer.cpp
+++ b/src/core/outputlayer.cpp
@@ -62,12 +62,12 @@ bool OutputLayer::needsRepaint() const
     return !m_repaints.isEmpty();
 }
 
-bool OutputLayer::doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
+bool OutputLayer::doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame)
 {
     return false;
 }
 
-bool OutputLayer::attemptScanout(SurfaceItem *surfaceItem, const std::shared_ptr<OutputFrame> &frame)
+bool OutputLayer::importScanoutBuffer(SurfaceItem *surfaceItem, const std::shared_ptr<OutputFrame> &frame)
 {
     SurfaceItemWayland *wayland = qobject_cast<SurfaceItemWayland *>(surfaceItem);
     if (!wayland || !wayland->surface()) {
@@ -91,7 +91,7 @@ bool OutputLayer::attemptScanout(SurfaceItem *surfaceItem, const std::shared_ptr
     m_bufferTransform = surfaceItem->bufferTransform();
     const auto desiredTransform = m_output ? m_output->transform() : OutputTransform::Kind::Normal;
     m_offloadTransform = m_bufferTransform.combine(desiredTransform.inverted());
-    const bool ret = doAttemptScanout(buffer, surfaceItem->colorDescription(), frame);
+    const bool ret = doImportScanoutBuffer(buffer, surfaceItem->colorDescription(), frame);
     if (ret) {
         surfaceItem->resetDamage();
         // ensure the pixmap is updated when direct scanout ends
diff --git a/src/core/outputlayer.h b/src/core/outputlayer.h
index 2c42ce34c95..dcc9a036395 100644
--- a/src/core/outputlayer.h
+++ b/src/core/outputlayer.h
@@ -62,10 +62,11 @@ public:
     bool endFrame(const QRegion &renderedRegion, const QRegion &damagedRegion, OutputFrame *frame);
 
     /**
-     * Tries to import the newest buffer of the surface for direct scanout
-     * Returns @c true if scanout succeeds, @c false if rendering is necessary
+     * Tries to import the newest buffer of the surface for direct scanout and does some early checks
+     * for whether or not direct scanout *could* be successful
+     * A presentation request on the output must however be used afterwards to find out if it's actually successful!
      */
-    bool attemptScanout(SurfaceItem *item, const std::shared_ptr<OutputFrame> &frame);
+    bool importScanoutBuffer(SurfaceItem *item, const std::shared_ptr<OutputFrame> &frame);
 
     /**
      * Notify that there's no scanout candidate this frame
@@ -95,7 +96,7 @@ public:
     OutputTransform bufferTransform() const;
 
 protected:
-    virtual bool doAttemptScanout(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame);
+    virtual bool doImportScanoutBuffer(GraphicsBuffer *buffer, const ColorDescription &color, const std::shared_ptr<OutputFrame> &frame);
     virtual std::optional<OutputLayerBeginFrameInfo> doBeginFrame() = 0;
     virtual bool doEndFrame(const QRegion &renderedRegion, const QRegion &damagedRegion, OutputFrame *frame) = 0;
 
diff --git a/src/core/renderbackend.cpp b/src/core/renderbackend.cpp
index d0cdb45380e..cd7666764a4 100644
--- a/src/core/renderbackend.cpp
+++ b/src/core/renderbackend.cpp
@@ -147,6 +147,16 @@ std::chrono::nanoseconds OutputFrame::predictedRenderTime() const
     return m_predictedRenderTime;
 }
 
+void OutputFrame::setDirectScanout(bool b)
+{
+    m_directScanout = b;
+}
+
+bool OutputFrame::isDirectScanout() const
+{
+    return m_directScanout;
+}
+
 RenderBackend::RenderBackend(QObject *parent)
     : QObject(parent)
 {
diff --git a/src/core/renderbackend.h b/src/core/renderbackend.h
index b4bbe2f8ed7..cc8cfa96f22 100644
--- a/src/core/renderbackend.h
+++ b/src/core/renderbackend.h
@@ -96,6 +96,9 @@ public:
     std::chrono::nanoseconds refreshDuration() const;
     std::chrono::nanoseconds predictedRenderTime() const;
 
+    void setDirectScanout(bool b);
+    bool isDirectScanout() const;
+
 private:
     std::optional<RenderTimeSpan> queryRenderTime() const;
 
@@ -109,6 +112,7 @@ private:
     QRegion m_damage;
     std::vector<std::unique_ptr<RenderTimeQuery>> m_renderTimeQueries;
     bool m_presented = false;
+    bool m_directScanout = false;
 };
 
 /**
@@ -128,7 +132,7 @@ public:
 
     virtual OutputLayer *primaryLayer(Output *output) = 0;
     virtual OutputLayer *cursorLayer(Output *output);
-    virtual void present(Output *output, const std::shared_ptr<OutputFrame> &frame) = 0;
+    virtual bool present(Output *output, const std::shared_ptr<OutputFrame> &frame) = 0;
 
     virtual DrmDevice *drmDevice() const;
 
-- 
GitLab

From 7f8e0b644fe107c50f688452252be4505c43053b Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Sat, 6 Jul 2024 15:37:35 +0200
Subject: [PATCH] rules: add window rule to force tearing on or off

This allows the user to override which presentation mode individual apps request
---
 src/compositor_wayland.cpp    | 2 +-
 src/kcms/rules/rulesmodel.cpp | 5 +++++
 src/rules.cpp                 | 8 +++++++-
 src/rules.h                   | 4 ++++
 src/rulesettings.kcfg         | 9 +++++++++
 src/window.cpp                | 5 +++++
 src/window.h                  | 1 +
 7 files changed, 32 insertions(+), 2 deletions(-)

diff --git a/src/compositor_wayland.cpp b/src/compositor_wayland.cpp
index 8cf486e6c4e..42ea2d6d937 100644
--- a/src/compositor_wayland.cpp
+++ b/src/compositor_wayland.cpp
@@ -307,7 +307,7 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
 
         const bool wantsAdaptiveSync = activeWindow && activeWindow->isOnOutput(output) && activeWindow->wantsAdaptiveSync();
         const bool vrr = (output->capabilities() & Output::Capability::Vrr) && (output->vrrPolicy() == VrrPolicy::Always || (output->vrrPolicy() == VrrPolicy::Automatic && wantsAdaptiveSync));
-        const bool tearing = (output->capabilities() & Output::Capability::Tearing) && options->allowTearing() && activeFullscreenItem && activeFullscreenItem->presentationHint() == PresentationModeHint::Async;
+        const bool tearing = (output->capabilities() & Output::Capability::Tearing) && options->allowTearing() && activeFullscreenItem && activeWindow->wantsTearing(activeFullscreenItem->presentationHint() == PresentationModeHint::Async);
         if (vrr) {
             frame->setPresentationMode(tearing ? PresentationMode::AdaptiveAsync : PresentationMode::AdaptiveSync);
         } else {
diff --git a/src/kcms/rules/rulesmodel.cpp b/src/kcms/rules/rulesmodel.cpp
index c89c976f811..f71bf366ce7 100644
--- a/src/kcms/rules/rulesmodel.cpp
+++ b/src/kcms/rules/rulesmodel.cpp
@@ -724,6 +724,11 @@ void RulesModel::populateRuleList()
                          RulePolicy::ForceRule, RuleItem::Boolean,
                          i18n("Adaptive Sync"), i18n("Appearance & Fixes"),
                          QIcon::fromTheme("monitor-symbolic")));
+
+    addRule(new RuleItem(QLatin1String("tearing"),
+                         RulePolicy::ForceRule, RuleItem::Boolean,
+                         i18n("Allow Tearing"), i18n("Appearance & Fixes"),
+                         QIcon::fromTheme("monitor-symbolic")));
 }
 
 const QHash<QString, QString> RulesModel::x11PropertyHash()
diff --git a/src/rules.cpp b/src/rules.cpp
index 7e7a1f1c77e..8b6091ab180 100644
--- a/src/rules.cpp
+++ b/src/rules.cpp
@@ -76,6 +76,7 @@ Rules::Rules()
     , disableglobalshortcutsrule(UnusedForceRule)
     , desktopfilerule(UnusedSetRule)
     , adaptivesyncrule(UnusedForceRule)
+    , tearingrule(UnusedForceRule)
 {
 }
 
@@ -160,6 +161,7 @@ void Rules::readFromSettings(const RuleSettings *settings)
     READ_SET_RULE(desktopfile);
     READ_FORCE_RULE(layer, );
     READ_FORCE_RULE(adaptivesync, );
+    READ_FORCE_RULE(tearing, );
 }
 
 #undef READ_MATCH_STRING
@@ -291,7 +293,8 @@ bool Rules::isEmpty() const
             && disableglobalshortcutsrule == UnusedForceRule
             && desktopfilerule == UnusedSetRule
             && layerrule == UnusedForceRule
-            && adaptivesyncrule == UnusedForceRule);
+            && adaptivesyncrule == UnusedForceRule)
+        && tearingrule == UnusedForceRule;
 }
 
 Rules::ForceRule Rules::convertForceRule(int v)
@@ -686,6 +689,7 @@ APPLY_RULE(shortcut, Shortcut, QString)
 APPLY_FORCE_RULE(disableglobalshortcuts, DisableGlobalShortcuts, bool)
 APPLY_RULE(desktopfile, DesktopFile, QString)
 APPLY_FORCE_RULE(adaptivesync, AdaptiveSync, bool)
+APPLY_FORCE_RULE(tearing, Tearing, bool)
 
 #undef APPLY_RULE
 #undef APPLY_FORCE_RULE
@@ -745,6 +749,7 @@ bool Rules::discardUsed(bool withdrawn)
     DISCARD_USED_SET_RULE(desktopfile);
     DISCARD_USED_FORCE_RULE(layer);
     DISCARD_USED_FORCE_RULE(adaptivesync);
+    DISCARD_USED_FORCE_RULE(tearing);
 
     return changed;
 }
@@ -893,6 +898,7 @@ CHECK_FORCE_RULE(DisableGlobalShortcuts, bool)
 CHECK_RULE(DesktopFile, QString)
 CHECK_FORCE_RULE(Layer, Layer)
 CHECK_FORCE_RULE(AdaptiveSync, bool)
+CHECK_FORCE_RULE(Tearing, bool)
 
 #undef CHECK_RULE
 #undef CHECK_FORCE_RULE
diff --git a/src/rules.h b/src/rules.h
index 69f761b65f6..6328baf4534 100644
--- a/src/rules.h
+++ b/src/rules.h
@@ -78,6 +78,7 @@ public:
     QString checkDesktopFile(QString desktopFile, bool init = false) const;
     Layer checkLayer(Layer layer) const;
     bool checkAdaptiveSync(bool adaptivesync) const;
+    bool checkTearing(bool requestsTearing) const;
 
 private:
     MaximizeMode checkMaximizeVert(MaximizeMode mode, bool init) const;
@@ -189,6 +190,7 @@ public:
     bool applyDesktopFile(QString &desktopFile, bool init) const;
     bool applyLayer(enum Layer &layer) const;
     bool applyAdaptiveSync(bool &adaptivesync) const;
+    bool applyTearing(bool &tearing) const;
 
 private:
 #endif
@@ -295,6 +297,8 @@ private:
     SetRule desktopfilerule;
     bool adaptivesync;
     ForceRule adaptivesyncrule;
+    bool tearing;
+    ForceRule tearingrule;
     friend QDebug &operator<<(QDebug &stream, const Rules *);
 };
 
diff --git a/src/rulesettings.kcfg b/src/rulesettings.kcfg
index 67cf4f7f382..01ee3a1ce8b 100644
--- a/src/rulesettings.kcfg
+++ b/src/rulesettings.kcfg
@@ -450,5 +450,14 @@
       <label>AdaptiveSync rule type</label>
       <default code="true">Rules::UnusedForceRule</default>
     </entry>
+
+    <entry name="tearing" type="Bool">
+      <label>Allow Tearing</label>
+      <default>true</default>
+    </entry>
+    <entry name="tearingrule" type="Int">
+      <label>Tearing rule type</label>
+      <default code="true">Rules::UnusedForceRule</default>
+    </entry>
   </group>
 </kcfg>
diff --git a/src/window.cpp b/src/window.cpp
index f8f10abeb7c..c5b8b94ad22 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -4027,6 +4027,11 @@ bool Window::wantsAdaptiveSync() const
     return rules()->checkAdaptiveSync(isFullScreen());
 }
 
+bool Window::wantsTearing(bool tearingRequested) const
+{
+    return rules()->checkTearing(tearingRequested);
+}
+
 /**
  * Returns @c true if the Window can be minimized; otherwise @c false.
  *
diff --git a/src/window.h b/src/window.h
index fb883fb6b82..61ecd288cb1 100644
--- a/src/window.h
+++ b/src/window.h
@@ -999,6 +999,7 @@ public:
     virtual void setFullScreen(bool set);
 
     bool wantsAdaptiveSync() const;
+    bool wantsTearing(bool tearingRequested) const;
 
     QRectF geometryRestore() const;
     void setGeometryRestore(const QRectF &rect);
-- 
GitLab

