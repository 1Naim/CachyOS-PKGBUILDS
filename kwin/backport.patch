From a004ebd54e3a433b821cc8062456586a35f2ade9 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Wed, 12 Jun 2024 23:37:38 +0300
Subject: [PATCH 01/17] autotests: Add a missing mock definition of
 Xcb::toXNative(QRectF)

(cherry picked from commit 4db2742e96ccc0a106a1d962207a51bc417b8ade)
---
 autotests/xcb_scaling_mock.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/autotests/xcb_scaling_mock.cpp b/autotests/xcb_scaling_mock.cpp
index 9493cf23cd..8b5d44d63c 100644
--- a/autotests/xcb_scaling_mock.cpp
+++ b/autotests/xcb_scaling_mock.cpp
@@ -17,6 +17,11 @@ uint32_t Xcb::toXNative(qreal value)
     return value;
 }
 
+QRect Xcb::toXNative(const QRectF &rect)
+{
+    return rect.toRect();
+}
+
 qreal Xcb::fromXNative(int value)
 {
     return value;
-- 
2.45.2

From 5e3a5f1beb3ff23825f803b8ebf1558c100871b3 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Wed, 12 Jun 2024 23:00:23 +0300
Subject: [PATCH 02/17] Avoid sending X11 sync request if new logical geometry
 doesn't change the device geometry

There are two mechanisms to throttle ConfigureNotify events during
interactive resize:

- either using XSync
- or by a dummy QTimer

The QTimer approach is pretty straightforward: the wm configures the
window, blocks the interactive resize operation and arms a timer to
unblock it some time later in the future.

With the xsync approach, the wm sends an xsync request, makes a
call to XConfigureWindow(), and blocks interactive resize until
the xsync request is acked by the client. When the client sees the
ConfigureNotify event, it is going to repaint and ack the xsync request.
When the xsync request is acked, the wm will apply new geometry and
unblock interactive resize.

After the scaling changes, the logical geometry can have some fractional
part, which gets rounded when configuring the X windows. Due to that,
it's possible to encounter the case where the logical geometry changes,
but the native/device geometry does not due to std::round(). In that
case, the wm should not send an xsync request because the client won't
ack it because the device geometry has not changed.

BUG: 488223
(cherry picked from commit 21a45c2700906ef7843cee93d7fdab77ee4e9d35)
---
 src/utils/xcbutils.h | 22 ++++++++++++++++++----
 src/x11window.cpp    | 23 ++++++++++++++++-------
 2 files changed, 34 insertions(+), 11 deletions(-)

diff --git a/src/utils/xcbutils.h b/src/utils/xcbutils.h
index 112522e196..7fffaf5cac 100644
--- a/src/utils/xcbutils.h
+++ b/src/utils/xcbutils.h
@@ -1642,6 +1642,10 @@ public:
     {
         return m_logicGeometry;
     }
+    QRect deviceGeometry() const
+    {
+        return m_deviceGeometry;
+    }
     /**
      * Configures the window with a new geometry.
      * @param geometry The new window geometry to be used
@@ -1686,6 +1690,7 @@ private:
     xcb_window_t m_window;
     bool m_destroy;
     QRectF m_logicGeometry;
+    QRect m_deviceGeometry;
 };
 
 inline Window::Window(xcb_window_t window, bool destroy)
@@ -1744,9 +1749,13 @@ inline void Window::create(const QRectF &geometry, uint32_t mask, const uint32_t
 inline xcb_window_t Window::doCreate(const QRectF &geometry, uint16_t windowClass, uint32_t mask, const uint32_t *values, xcb_window_t parent)
 {
     m_logicGeometry = geometry;
+    m_deviceGeometry = Xcb::toXNative(geometry);
     xcb_window_t w = xcb_generate_id(connection());
     xcb_create_window(connection(), XCB_COPY_FROM_PARENT, w, parent,
-                      Xcb::toXNative(geometry.x()), Xcb::toXNative(geometry.y()), Xcb::toXNative(geometry.width()), Xcb::toXNative(geometry.height()),
+                      m_deviceGeometry.x(),
+                      m_deviceGeometry.y(),
+                      m_deviceGeometry.width(),
+                      m_deviceGeometry.height(),
                       0, windowClass, XCB_COPY_FROM_PARENT, mask, values);
     return w;
 }
@@ -1766,11 +1775,12 @@ inline void Window::setGeometry(const QRectF &geometry)
 inline void Window::setGeometry(qreal x, qreal y, qreal width, qreal height)
 {
     m_logicGeometry.setRect(x, y, width, height);
+    m_deviceGeometry = Xcb::toXNative(m_logicGeometry);
     if (!isValid()) {
         return;
     }
     const uint16_t mask = XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT;
-    const uint32_t values[] = {Xcb::toXNative(x), Xcb::toXNative(y), Xcb::toXNative(width), Xcb::toXNative(height)};
+    const uint32_t values[] = {uint32_t(m_deviceGeometry.x()), uint32_t(m_deviceGeometry.y()), uint32_t(m_deviceGeometry.width()), uint32_t(m_deviceGeometry.height())};
     xcb_configure_window(connection(), m_window, mask, values);
 }
 
@@ -1782,10 +1792,13 @@ inline void Window::move(const QPointF &pos)
 inline void Window::move(qreal x, qreal y)
 {
     m_logicGeometry.moveTo(x, y);
+    m_deviceGeometry.moveTo(Xcb::toXNative(x), Xcb::toXNative(y));
     if (!isValid()) {
         return;
     }
-    moveWindow(m_window, x, y);
+    const uint16_t mask = XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y;
+    const uint32_t values[] = {uint32_t(m_deviceGeometry.x()), uint32_t(m_deviceGeometry.y())};
+    xcb_configure_window(connection(), m_window, mask, values);
 }
 
 inline void Window::resize(const QSizeF &size)
@@ -1796,11 +1809,12 @@ inline void Window::resize(const QSizeF &size)
 inline void Window::resize(qreal width, qreal height)
 {
     m_logicGeometry.setSize(QSizeF(width, height));
+    m_deviceGeometry.setSize(QSize(Xcb::toXNative(width), Xcb::toXNative(height)));
     if (!isValid()) {
         return;
     }
     const uint16_t mask = XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT;
-    const uint32_t values[] = {Xcb::toXNative(width), Xcb::toXNative(height)};
+    const uint32_t values[] = {uint32_t(m_deviceGeometry.width()), uint32_t(m_deviceGeometry.height())};
     xcb_configure_window(connection(), m_window, mask, values);
 }
 
diff --git a/src/x11window.cpp b/src/x11window.cpp
index 0f539d1062..1afcea8bc5 100644
--- a/src/x11window.cpp
+++ b/src/x11window.cpp
@@ -4785,7 +4785,19 @@ bool X11Window::isWaitingForInteractiveResizeSync() const
 
 void X11Window::doInteractiveResizeSync(const QRectF &rect)
 {
-    setMoveResizeGeometry(rect);
+    const QRectF moveResizeFrameGeometry = Xcb::fromXNative(Xcb::toXNative(rect));
+    const QRectF moveResizeClientGeometry = frameRectToClientRect(moveResizeFrameGeometry);
+    const QRectF moveResizeBufferGeometry = frameRectToBufferRect(moveResizeFrameGeometry);
+
+    const QRectF xFrameGeometry = moveResizeBufferGeometry;
+    const QRectF xWrapperGeometry = moveResizeClientGeometry.translated(-moveResizeBufferGeometry.topLeft());
+    const QRectF xClientGeometry = QRectF(QPointF(0, 0), moveResizeClientGeometry.size());
+
+    if (m_frame.deviceGeometry() == Xcb::toXNative(xFrameGeometry) && m_wrapper.deviceGeometry() == Xcb::toXNative(xWrapperGeometry) && m_client.deviceGeometry() == Xcb::toXNative(xClientGeometry)) {
+        return;
+    }
+
+    setMoveResizeGeometry(moveResizeFrameGeometry);
 
     if (!m_syncRequest.timeout) {
         m_syncRequest.timeout = new QTimer(this);
@@ -4805,16 +4817,13 @@ void X11Window::doInteractiveResizeSync(const QRectF &rect)
         m_syncRequest.timeout->start(33);
     }
 
-    const QRectF moveResizeClientGeometry = frameRectToClientRect(moveResizeGeometry());
-    const QRectF moveResizeBufferGeometry = frameRectToBufferRect(moveResizeGeometry());
-
     // According to the Composite extension spec, a window will get a new pixmap allocated each time
     // it is mapped or resized. Given that we redirect frame windows and not client windows, we have
     // to resize the frame window in order to forcefully reallocate offscreen storage. If we don't do
     // this, then we might render partially updated client window. I know, it sucks.
-    m_frame.setGeometry(moveResizeBufferGeometry);
-    m_wrapper.setGeometry(moveResizeClientGeometry.translated(-moveResizeBufferGeometry.topLeft()));
-    m_client.setGeometry(QRectF(QPointF(0, 0), moveResizeClientGeometry.size()));
+    m_frame.setGeometry(xFrameGeometry);
+    m_wrapper.setGeometry(xWrapperGeometry);
+    m_client.setGeometry(xClientGeometry);
 }
 
 void X11Window::handleSyncTimeout()
-- 
2.45.2

From 9a0733a8b932af37ac19289957f362372f2631df Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 13 Jun 2024 15:51:45 +0300
Subject: [PATCH 03/17] plugins/nightlight: Ensure the target temperature
 remains within reasonable bounds

The interpolated temperature can get out of the bounds of [target1, target2]
if the current time is slightly earlier than m_prev.first, which can be
unexpected. This change addresses that by adding a relevant guard.

(cherry picked from commit f46174453db230a7ef42c02445d97f4895f51aff)
---
 src/plugins/nightlight/nightlightmanager.cpp | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/src/plugins/nightlight/nightlightmanager.cpp b/src/plugins/nightlight/nightlightmanager.cpp
index fab9c06d4d..a711dc5809 100644
--- a/src/plugins/nightlight/nightlightmanager.cpp
+++ b/src/plugins/nightlight/nightlightmanager.cpp
@@ -609,16 +609,18 @@ int NightLightManager::currentTargetTemp() const
     const QDateTime todayNow = QDateTime::currentDateTime();
 
     auto f = [this, todayNow](int target1, int target2) {
-        if (todayNow < m_prev.second) {
-            double residueQuota = todayNow.msecsTo(m_prev.second) / (double)m_prev.first.msecsTo(m_prev.second);
-
-            double ret = (int)((1. - residueQuota) * (double)target2 + residueQuota * (double)target1);
-            // remove single digits
-            ret = ((int)(0.1 * ret)) * 10;
-            return (int)ret;
-        } else {
+        if (todayNow <= m_prev.first) {
+            return target1;
+        }
+        if (todayNow >= m_prev.second) {
             return target2;
         }
+
+        double residueQuota = todayNow.msecsTo(m_prev.second) / (double)m_prev.first.msecsTo(m_prev.second);
+        double ret = (int)((1. - residueQuota) * (double)target2 + residueQuota * (double)target1);
+        // remove single digits
+        ret = ((int)(0.1 * ret)) * 10;
+        return (int)ret;
     };
 
     if (daylight()) {
-- 
2.45.2

From 2fe831852148456437933b8b2ecd9fa59eec3a05 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 14 Jun 2024 07:05:49 +0000
Subject: [PATCH 04/17] Also wake up screens on tablet interactions

BUG:451359
FIXED-IN:6.1.1


(cherry picked from commit c2141dc4efac6e7c51815aa57272b5537e60f101)

Co-authored-by: David Redondo <kde@david-redondo.de>
---
 src/dpmsinputeventfilter.cpp | 37 ++++++++++++++++++++++++++++++++++++
 src/dpmsinputeventfilter.h   |  5 +++++
 2 files changed, 42 insertions(+)

diff --git a/src/dpmsinputeventfilter.cpp b/src/dpmsinputeventfilter.cpp
index b6314c3c9c..7dbaed8d0d 100644
--- a/src/dpmsinputeventfilter.cpp
+++ b/src/dpmsinputeventfilter.cpp
@@ -129,6 +129,43 @@ bool DpmsInputEventFilter::touchMotion(qint32 id, const QPointF &pos, std::chron
     return true;
 }
 
+bool DpmsInputEventFilter::tabletToolEvent(TabletEvent *event)
+{
+    if (event->type() == QEvent::TabletPress) {
+        // Only wake when the tool is actually pressed down not just hovered over the tablet
+        notify();
+    }
+    return true;
+}
+
+bool DpmsInputEventFilter::tabletToolButtonEvent(uint button, bool pressed, const TabletToolId &tabletToolId, std::chrono::microseconds time)
+{
+    if (pressed) {
+        notify();
+    }
+    return true;
+}
+
+bool DpmsInputEventFilter::tabletPadButtonEvent(uint button, bool pressed, const TabletPadId &tabletPadId, std::chrono::microseconds time)
+{
+    if (pressed) {
+        notify();
+    }
+    return true;
+}
+
+bool DpmsInputEventFilter::tabletPadStripEvent(int number, int position, bool isFinger, const TabletPadId &tabletPadId, std::chrono::microseconds time)
+{
+    notify();
+    return true;
+}
+
+bool DpmsInputEventFilter::tabletPadRingEvent(int number, int position, bool isFinger, const TabletPadId &tabletPadId, std::chrono::microseconds time)
+{
+    notify();
+    return true;
+}
+
 void DpmsInputEventFilter::notify()
 {
     const QList<Output *> outputs = workspace()->outputs();
diff --git a/src/dpmsinputeventfilter.h b/src/dpmsinputeventfilter.h
index 461a040e4b..6cb28bd069 100644
--- a/src/dpmsinputeventfilter.h
+++ b/src/dpmsinputeventfilter.h
@@ -32,6 +32,11 @@ public:
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override;
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override;
     bool touchUp(qint32 id, std::chrono::microseconds time) override;
+    bool tabletToolEvent(TabletEvent *event) override;
+    bool tabletToolButtonEvent(uint button, bool pressed, const TabletToolId &tabletToolId, std::chrono::microseconds time) override;
+    bool tabletPadButtonEvent(uint button, bool pressed, const TabletPadId &tabletPadId, std::chrono::microseconds time) override;
+    bool tabletPadStripEvent(int number, int position, bool isFinger, const TabletPadId &tabletPadId, std::chrono::microseconds time) override;
+    bool tabletPadRingEvent(int number, int position, bool isFinger, const TabletPadId &tabletPadId, std::chrono::microseconds time) override;
 
 private:
     void notify();
-- 
2.45.2

From d0165bfe84dac0598f6fd9b85af9a5575db994bf Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 14 Jun 2024 11:45:48 +0000
Subject: [PATCH 05/17] Make Window::closeWindow() noop if the window is
 already closed

The surface handle can be dropped by that time. Also, there is no point
to ask the client to close the window again if it's already closed.


(cherry picked from commit ad980696185711619833799888d3c1afab9c3dd1)

Co-authored-by: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
---
 src/internalwindow.cpp     | 2 +-
 src/layershellv1window.cpp | 4 +++-
 src/x11window.cpp          | 3 +++
 src/xdgshellwindow.cpp     | 3 +++
 4 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/src/internalwindow.cpp b/src/internalwindow.cpp
index 645905af9f..b633bca464 100644
--- a/src/internalwindow.cpp
+++ b/src/internalwindow.cpp
@@ -172,7 +172,7 @@ QString InternalWindow::windowRole() const
 
 void InternalWindow::closeWindow()
 {
-    if (m_handle) {
+    if (!isDeleted()) {
         m_handle->hide();
     }
 }
diff --git a/src/layershellv1window.cpp b/src/layershellv1window.cpp
index 1bfa71c70c..eb89652166 100644
--- a/src/layershellv1window.cpp
+++ b/src/layershellv1window.cpp
@@ -211,7 +211,9 @@ void LayerShellV1Window::destroyWindow()
 
 void LayerShellV1Window::closeWindow()
 {
-    m_shellSurface->sendClosed();
+    if (!isDeleted()) {
+        m_shellSurface->sendClosed();
+    }
 }
 
 Layer LayerShellV1Window::belongsToLayer() const
diff --git a/src/x11window.cpp b/src/x11window.cpp
index 1afcea8bc5..2983b99397 100644
--- a/src/x11window.cpp
+++ b/src/x11window.cpp
@@ -2031,6 +2031,9 @@ bool X11Window::isCloseable() const
  */
 void X11Window::closeWindow()
 {
+    if (isDeleted()) {
+        return;
+    }
     if (!isCloseable()) {
         return;
     }
diff --git a/src/xdgshellwindow.cpp b/src/xdgshellwindow.cpp
index 4cc3800612..b846c509ca 100644
--- a/src/xdgshellwindow.cpp
+++ b/src/xdgshellwindow.cpp
@@ -668,6 +668,9 @@ void XdgToplevelWindow::applyWindowRules()
 
 void XdgToplevelWindow::closeWindow()
 {
+    if (isDeleted()) {
+        return;
+    }
     if (isCloseable()) {
         sendPing(PingReason::CloseWindow);
         m_shellSurface->sendClose();
-- 
2.45.2

From f254de35160b7d6f68737e2e1acfa619c6714f51 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 14 Jun 2024 12:25:42 +0000
Subject: [PATCH 06/17] plugins/nightlight: Make Night Light more robust to
 QTimer firing slightly earlier

Currently, resetSlowUpdateTimers() will start a timer that will pass
m_next.first as the current time to resetSlowUpdateTimers(). This kind
of works, but there are more code paths where updateTransitionTimings()
can be called.

This change hardens updateTransitionTimings() against the current time
being very close to the start of the next transition by introducing a
time fudge factor.

If we are currently 1 second away from the start of the next transition,
then it is assumed that that transition has been reached, and we need
to calculate the timings of a transition after that.


(cherry picked from commit fef2bfb93fab56dcda267882aa71a06508521dd4)

Co-authored-by: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
---
 src/plugins/nightlight/nightlightmanager.cpp | 38 +++++++++++++-------
 src/plugins/nightlight/nightlightmanager.h   |  4 +--
 2 files changed, 27 insertions(+), 15 deletions(-)

diff --git a/src/plugins/nightlight/nightlightmanager.cpp b/src/plugins/nightlight/nightlightmanager.cpp
index a711dc5809..ae22f02836 100644
--- a/src/plugins/nightlight/nightlightmanager.cpp
+++ b/src/plugins/nightlight/nightlightmanager.cpp
@@ -138,7 +138,7 @@ void NightLightManager::hardReset()
 {
     cancelAllTimers();
 
-    updateTransitionTimings(true);
+    updateTransitionTimings(true, QDateTime::currentDateTime());
     updateTargetTemperature();
 
     if (isEnabled() && !isInhibited()) {
@@ -300,7 +300,7 @@ void NightLightManager::resetAllTimers()
     cancelAllTimers();
     setRunning(isEnabled() && !isInhibited());
     // we do this also for active being false in order to reset the temperature back to the day value
-    updateTransitionTimings(false);
+    updateTransitionTimings(false, QDateTime::currentDateTime());
     updateTargetTemperature();
     resetQuickAdjustTimer(currentTargetTemp());
 }
@@ -356,7 +356,7 @@ void NightLightManager::quickAdjust(int targetTemp)
     }
 }
 
-void NightLightManager::resetSlowUpdateTimers(const QDateTime &todayNow)
+void NightLightManager::resetSlowUpdateTimers()
 {
     m_slowUpdateStartTimer.reset();
 
@@ -371,12 +371,13 @@ void NightLightManager::resetSlowUpdateTimers(const QDateTime &todayNow)
         return;
     }
 
+    const QDateTime todayNow = QDateTime::currentDateTime();
+
     // set up the next slow update
     m_slowUpdateStartTimer = std::make_unique<QTimer>();
     m_slowUpdateStartTimer->setSingleShot(true);
     connect(m_slowUpdateStartTimer.get(), &QTimer::timeout, this, [this]() {
-        const QDateTime nextMilestone = m_next.first; // make a copy so the current time stays the same after updateTransitionTimings() is called
-        resetSlowUpdateTimers(nextMilestone);
+        resetSlowUpdateTimers();
     });
     updateTransitionTimings(false, todayNow);
     updateTargetTemperature();
@@ -459,7 +460,7 @@ void NightLightManager::preview(uint previewTemp)
 void NightLightManager::stopPreview()
 {
     if (m_previewTimer && m_previewTimer->isActive()) {
-        updateTransitionTimings(false);
+        updateTransitionTimings(false, QDateTime::currentDateTime());
         updateTargetTemperature();
         resetQuickAdjustTimer(currentTargetTemp());
     }
@@ -483,14 +484,23 @@ void NightLightManager::updateTransitionTimings(bool force, const QDateTime &tod
     const auto oldPrev = m_prev;
     const auto oldNext = m_next;
 
+    // QTimer is not precise, it can timeout slightly earlier than expected. For example, if the
+    // morning time is 6:00, the timer can fire at 5:59:59. The purpose of this fudge factor is to
+    // make night light think that the morning transition has been reached even though we are not
+    // there yet by a few microseconds or milliseconds.
+    const int granularity = 1;
+
     if (m_mode == NightLightMode::Constant) {
         setDaylight(false);
         m_next = DateTimes();
         m_prev = DateTimes();
     } else if (m_mode == NightLightMode::Timings) {
-        const QDateTime nextMorB = QDateTime(todayNow.date().addDays(m_morning <= todayNow.time()), m_morning);
+        const bool passedMorning = todayNow.time().secsTo(m_morning) <= granularity;
+        const bool passedEvening = todayNow.time().secsTo(m_evening) <= granularity;
+
+        const QDateTime nextMorB = QDateTime(todayNow.date().addDays(passedMorning), m_morning);
         const QDateTime nextMorE = nextMorB.addSecs(m_trTime * 60);
-        const QDateTime nextEveB = QDateTime(todayNow.date().addDays(m_evening <= todayNow.time()), m_evening);
+        const QDateTime nextEveB = QDateTime(todayNow.date().addDays(passedEvening), m_evening);
         const QDateTime nextEveE = nextEveB.addSecs(m_trTime * 60);
 
         if (nextEveB < nextMorB) {
@@ -528,19 +538,21 @@ void NightLightManager::updateTransitionTimings(bool force, const QDateTime &tod
         }
 
         if (force || !checkAutomaticSunTimings()) {
-            // in case this fails, reset them
-            DateTimes morning = getSunTimings(todayNow, lat, lng, true);
-            if (todayNow < morning.first) {
+            const DateTimes morning = getSunTimings(todayNow, lat, lng, true);
+            if (todayNow.secsTo(morning.first) > granularity) {
+                // have not reached the morning yet
                 setDaylight(false);
                 m_prev = getSunTimings(todayNow.addDays(-1), lat, lng, false);
                 m_next = morning;
             } else {
-                DateTimes evening = getSunTimings(todayNow, lat, lng, false);
-                if (todayNow < evening.first) {
+                const DateTimes evening = getSunTimings(todayNow, lat, lng, false);
+                if (todayNow.secsTo(evening.first) > granularity) {
+                    // have not reached the evening yet, it's daylight
                     setDaylight(true);
                     m_prev = morning;
                     m_next = evening;
                 } else {
+                    // we are passed the evening, it's night time
                     setDaylight(false);
                     m_prev = evening;
                     m_next = getSunTimings(todayNow.addDays(1), lat, lng, true);
diff --git a/src/plugins/nightlight/nightlightmanager.h b/src/plugins/nightlight/nightlightmanager.h
index 7809fd1da5..a109a256c2 100644
--- a/src/plugins/nightlight/nightlightmanager.h
+++ b/src/plugins/nightlight/nightlightmanager.h
@@ -250,10 +250,10 @@ private:
     /**
      * Slow shift to daytime target Temperature
      */
-    void resetSlowUpdateTimers(const QDateTime &todayNow = QDateTime::currentDateTime());
+    void resetSlowUpdateTimers();
 
     void updateTargetTemperature();
-    void updateTransitionTimings(bool force, const QDateTime &todayNow = QDateTime::currentDateTime());
+    void updateTransitionTimings(bool force, const QDateTime &todayNow);
     DateTimes getSunTimings(const QDateTime &dateTime, double latitude, double longitude, bool morning) const;
     bool checkAutomaticSunTimings() const;
 
-- 
2.45.2

From 648e5c847e60cf238c0d366ee322c4727bd9e4fb Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 13 Jun 2024 15:46:11 +0300
Subject: [PATCH 07/17] plugins/screencast: Check compositing type

Screencasting only works with OpenGL compositing at the moment.

(cherry picked from commit 5fe9e9c7568b6c76bd4f516d8608b9b6dcdbbd5f)
---
 src/plugins/screencast/screencaststream.cpp | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/src/plugins/screencast/screencaststream.cpp b/src/plugins/screencast/screencaststream.cpp
index 194e967e88..cdb4841f9d 100644
--- a/src/plugins/screencast/screencaststream.cpp
+++ b/src/plugins/screencast/screencaststream.cpp
@@ -10,7 +10,6 @@
 #include "compositor.h"
 #include "core/drmdevice.h"
 #include "core/graphicsbufferallocator.h"
-#include "core/outputbackend.h"
 #include "core/renderbackend.h"
 #include "cursor.h"
 #include "kwinscreencast_logging.h"
@@ -20,7 +19,6 @@
 #include "opengl/glutils.h"
 #include "pipewirecore.h"
 #include "platformsupport/scenes/opengl/abstract_egl_backend.h"
-#include "platformsupport/scenes/opengl/openglbackend.h"
 #include "scene/workspacescene.h"
 #include "screencastbuffer.h"
 #include "screencastsource.h"
@@ -343,6 +341,12 @@ bool ScreenCastStream::init()
         return false;
     }
 
+    AbstractEglBackend *backend = qobject_cast<AbstractEglBackend *>(Compositor::self()->backend());
+    if (!backend) {
+        m_error = QStringLiteral("OpenGL compositing is required for screencasting");
+        return false;
+    }
+
     connect(m_pwCore.get(), &PipeWireCore::pipewireFailed, this, &ScreenCastStream::coreFailed);
 
     if (!createStream()) {
@@ -482,6 +486,11 @@ void ScreenCastStream::recordFrame(const QRegion &damage, Contents contents)
     m_pendingDamage = {};
     m_pendingContents = {};
 
+    AbstractEglBackend *backend = qobject_cast<AbstractEglBackend *>(Compositor::self()->backend());
+    if (!backend) {
+        return;
+    }
+
     struct pw_buffer *pwBuffer = pw_stream_dequeue_buffer(m_pwStream);
     if (!pwBuffer) {
         return;
@@ -506,7 +515,7 @@ void ScreenCastStream::recordFrame(const QRegion &damage, Contents contents)
         }
     }
 
-    EglContext *context = static_cast<AbstractEglBackend *>(Compositor::self()->backend())->openglContext();
+    EglContext *context = backend->openglContext();
     context->makeCurrent();
 
     if (effectiveContents & Content::Video) {
@@ -819,7 +828,7 @@ void ScreenCastStream::setCursorMode(ScreencastV1Interface::CursorMode mode, qre
 
 std::optional<ScreenCastDmaBufTextureParams> ScreenCastStream::testCreateDmaBuf(const QSize &size, quint32 format, const QList<uint64_t> &modifiers)
 {
-    AbstractEglBackend *backend = dynamic_cast<AbstractEglBackend *>(Compositor::self()->backend());
+    AbstractEglBackend *backend = qobject_cast<AbstractEglBackend *>(Compositor::self()->backend());
     if (!backend) {
         return std::nullopt;
     }
-- 
2.45.2

From acf9105e4ecf15fa8a53e4d9c7ba05e2a5a153d8 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 14 Jun 2024 14:36:52 +0000
Subject: [PATCH 08/17] plugins/nightlight: Remove premature optimization in
 updateTransitionTimings()

There are a couple of reasons why it's worth removing it:

- it's error prone. If one forgets to pass correct "force" flag, night
  light will break
- it contributes some complexity
- updateTransitionTimings() is not called in any hot path and the code
  that calculates the position of the Sun is not resource intensive


(cherry picked from commit 07f266e7c73df85eea448b85af170a04eba63a11)

Co-authored-by: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
---
 src/plugins/nightlight/nightlightmanager.cpp | 64 ++++++--------------
 src/plugins/nightlight/nightlightmanager.h   |  3 +-
 2 files changed, 20 insertions(+), 47 deletions(-)

diff --git a/src/plugins/nightlight/nightlightmanager.cpp b/src/plugins/nightlight/nightlightmanager.cpp
index ae22f02836..bddf6d0973 100644
--- a/src/plugins/nightlight/nightlightmanager.cpp
+++ b/src/plugins/nightlight/nightlightmanager.cpp
@@ -138,7 +138,7 @@ void NightLightManager::hardReset()
 {
     cancelAllTimers();
 
-    updateTransitionTimings(true, QDateTime::currentDateTime());
+    updateTransitionTimings(QDateTime::currentDateTime());
     updateTargetTemperature();
 
     if (isEnabled() && !isInhibited()) {
@@ -300,7 +300,7 @@ void NightLightManager::resetAllTimers()
     cancelAllTimers();
     setRunning(isEnabled() && !isInhibited());
     // we do this also for active being false in order to reset the temperature back to the day value
-    updateTransitionTimings(false, QDateTime::currentDateTime());
+    updateTransitionTimings(QDateTime::currentDateTime());
     updateTargetTemperature();
     resetQuickAdjustTimer(currentTargetTemp());
 }
@@ -379,7 +379,7 @@ void NightLightManager::resetSlowUpdateTimers()
     connect(m_slowUpdateStartTimer.get(), &QTimer::timeout, this, [this]() {
         resetSlowUpdateTimers();
     });
-    updateTransitionTimings(false, todayNow);
+    updateTransitionTimings(todayNow);
     updateTargetTemperature();
 
     const int diff = todayNow.msecsTo(m_next.first);
@@ -460,7 +460,7 @@ void NightLightManager::preview(uint previewTemp)
 void NightLightManager::stopPreview()
 {
     if (m_previewTimer && m_previewTimer->isActive()) {
-        updateTransitionTimings(false, QDateTime::currentDateTime());
+        updateTransitionTimings(QDateTime::currentDateTime());
         updateTargetTemperature();
         resetQuickAdjustTimer(currentTargetTemp());
     }
@@ -479,7 +479,7 @@ void NightLightManager::updateTargetTemperature()
     Q_EMIT targetTemperatureChanged();
 }
 
-void NightLightManager::updateTransitionTimings(bool force, const QDateTime &todayNow)
+void NightLightManager::updateTransitionTimings(const QDateTime &todayNow)
 {
     const auto oldPrev = m_prev;
     const auto oldNext = m_next;
@@ -522,43 +522,26 @@ void NightLightManager::updateTransitionTimings(bool force, const QDateTime &tod
             lng = m_lngFixed;
         }
 
-        if (!force) {
-            // first try by only switching the timings
-            if (m_prev.first.date() == m_next.first.date()) {
-                // next is evening
+        const DateTimes morning = getSunTimings(todayNow, lat, lng, true);
+        if (todayNow.secsTo(morning.first) > granularity) {
+            // have not reached the morning yet
+            setDaylight(false);
+            m_prev = getSunTimings(todayNow.addDays(-1), lat, lng, false);
+            m_next = morning;
+        } else {
+            const DateTimes evening = getSunTimings(todayNow, lat, lng, false);
+            if (todayNow.secsTo(evening.first) > granularity) {
+                // have not reached the evening yet, it's daylight
                 setDaylight(true);
-                m_prev = m_next;
-                m_next = getSunTimings(todayNow, lat, lng, false);
+                m_prev = morning;
+                m_next = evening;
             } else {
-                // next is morning
+                // we are passed the evening, it's night time
                 setDaylight(false);
-                m_prev = m_next;
+                m_prev = evening;
                 m_next = getSunTimings(todayNow.addDays(1), lat, lng, true);
             }
         }
-
-        if (force || !checkAutomaticSunTimings()) {
-            const DateTimes morning = getSunTimings(todayNow, lat, lng, true);
-            if (todayNow.secsTo(morning.first) > granularity) {
-                // have not reached the morning yet
-                setDaylight(false);
-                m_prev = getSunTimings(todayNow.addDays(-1), lat, lng, false);
-                m_next = morning;
-            } else {
-                const DateTimes evening = getSunTimings(todayNow, lat, lng, false);
-                if (todayNow.secsTo(evening.first) > granularity) {
-                    // have not reached the evening yet, it's daylight
-                    setDaylight(true);
-                    m_prev = morning;
-                    m_next = evening;
-                } else {
-                    // we are passed the evening, it's night time
-                    setDaylight(false);
-                    m_prev = evening;
-                    m_next = getSunTimings(todayNow.addDays(1), lat, lng, true);
-                }
-            }
-        }
     }
 
     if (oldPrev != m_prev) {
@@ -594,15 +577,6 @@ DateTimes NightLightManager::getSunTimings(const QDateTime &dateTime, double lat
     return dateTimes;
 }
 
-bool NightLightManager::checkAutomaticSunTimings() const
-{
-    if (m_prev.first.isValid() && m_prev.second.isValid() && m_next.first.isValid() && m_next.second.isValid()) {
-        const QDateTime todayNow = QDateTime::currentDateTime();
-        return m_prev.first <= todayNow && todayNow < m_next.first && m_prev.first.msecsTo(m_next.first) < MSC_DAY * 23. / 24;
-    }
-    return false;
-}
-
 bool NightLightManager::daylight() const
 {
     return m_daylight;
diff --git a/src/plugins/nightlight/nightlightmanager.h b/src/plugins/nightlight/nightlightmanager.h
index a109a256c2..42d33a38ab 100644
--- a/src/plugins/nightlight/nightlightmanager.h
+++ b/src/plugins/nightlight/nightlightmanager.h
@@ -253,9 +253,8 @@ private:
     void resetSlowUpdateTimers();
 
     void updateTargetTemperature();
-    void updateTransitionTimings(bool force, const QDateTime &todayNow);
+    void updateTransitionTimings(const QDateTime &todayNow);
     DateTimes getSunTimings(const QDateTime &dateTime, double latitude, double longitude, bool morning) const;
-    bool checkAutomaticSunTimings() const;
 
     void commitGammaRamps(int temperature);
 
-- 
2.45.2

From c1a924632655cd07f4133e45b72afe591d62f4a3 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 14 Jun 2024 15:20:41 +0000
Subject: [PATCH 09/17] plugins/nightlight: Guard against invalid timings in
 the config

Morning and evening timings should be ordered correctly. When computing
the daylight duration, that ternary operator should not be needed and it
hides other bugs.


(cherry picked from commit 786b3ffbaedc5d4246d8a9d0e26b287d7cc00c48)

Co-authored-by: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
---
 src/plugins/nightlight/nightlightmanager.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/plugins/nightlight/nightlightmanager.cpp b/src/plugins/nightlight/nightlightmanager.cpp
index bddf6d0973..e58d160762 100644
--- a/src/plugins/nightlight/nightlightmanager.cpp
+++ b/src/plugins/nightlight/nightlightmanager.cpp
@@ -279,8 +279,12 @@ void NightLightManager::readConfig()
     // fixed timings
     QTime mrB = QTime::fromString(s->morningBeginFixed(), "hhmm");
     QTime evB = QTime::fromString(s->eveningBeginFixed(), "hhmm");
+    if (mrB >= evB) {
+        mrB = QTime(6, 0);
+        evB = QTime(18, 0);
+    }
 
-    int diffME = evB > mrB ? mrB.msecsTo(evB) : evB.msecsTo(mrB);
+    int diffME = mrB.msecsTo(evB);
     int diffMin = std::min(diffME, MSC_DAY - diffME);
 
     int trTime = s->transitionTime() * 1000 * 60;
-- 
2.45.2

From 9148d188c957ad533e853f3a61e4cec74e9fe1e1 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Sun, 16 Jun 2024 18:57:03 +0000
Subject: [PATCH 10/17] backends/drm: don't do direct scanout when HDR
 brightness isn't 1

Otherwise the brightness multiplier doesn't get applied


(cherry picked from commit 178d49093c86f2854929986b14a69f8ec5127d65)

Co-authored-by: Xaver Hugl <xaver.hugl@gmail.com>
---
 src/backends/drm/drm_egl_layer.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/backends/drm/drm_egl_layer.cpp b/src/backends/drm/drm_egl_layer.cpp
index 6069905244..52d97c7667 100644
--- a/src/backends/drm/drm_egl_layer.cpp
+++ b/src/backends/drm/drm_egl_layer.cpp
@@ -90,7 +90,7 @@ bool EglGbmLayer::doAttemptScanout(GraphicsBuffer *buffer, const ColorDescriptio
     if (directScanoutDisabled) {
         return false;
     }
-    if (m_pipeline->output()->channelFactors() != QVector3D(1, 1, 1) || m_pipeline->iccProfile()) {
+    if (m_pipeline->output()->channelFactors() != QVector3D(1, 1, 1) || (m_pipeline->output()->highDynamicRange() && m_pipeline->output()->brightness() != 1) || m_pipeline->iccProfile()) {
         // TODO use GAMMA_LUT, CTM and DEGAMMA_LUT to allow direct scanout with HDR
         return false;
     }
-- 
2.45.2

From f9d2a49492248995b963bd356e9d90421b6715a4 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 17 Jun 2024 12:10:47 +0000
Subject: [PATCH 11/17] wayland: Fix buffer ref'ing in
 org_kde_kwin_shadow.commit

In case the current state and the pending state have the same buffer for
a particular side or a corner, that buffer can be prematurely released
because the buffer in the current state is unreferenced first.

The ref/unref order should be vice versa to ensure that the GraphicsBuffer
is not released prematurely.


(cherry picked from commit 1a7c94b69285d3e5f5f26ca9b0214f49fe101b16)

Co-authored-by: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
---
 src/wayland/shadow.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/wayland/shadow.cpp b/src/wayland/shadow.cpp
index 1a6e5eed46..4b831e5446 100644
--- a/src/wayland/shadow.cpp
+++ b/src/wayland/shadow.cpp
@@ -139,12 +139,12 @@ void ShadowInterfacePrivate::org_kde_kwin_shadow_commit(Resource *resource)
 {
 #define BUFFER(__FLAG__, __PART__)                        \
     if (pending.flags & State::Flags::__FLAG__##Buffer) { \
-        if (current.__PART__) {                           \
-            current.__PART__->unref();                    \
-        }                                                 \
         if (pending.__PART__) {                           \
             pending.__PART__->ref();                      \
         }                                                 \
+        if (current.__PART__) {                           \
+            current.__PART__->unref();                    \
+        }                                                 \
         current.__PART__ = pending.__PART__;              \
     }
     BUFFER(Left, left)
-- 
2.45.2

From 9f9e2f3580d31c670ad132e11ffca700739817be Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 17 Jun 2024 19:55:26 +0000
Subject: [PATCH 12/17] Get rid of extra string allocations in
 src/inputmethod.cpp

(cherry picked from commit 0fc6c6800ef7f8889f17c34ef93225622df707d0)

Co-authored-by: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
---
 src/inputmethod.cpp | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/inputmethod.cpp b/src/inputmethod.cpp
index 17d56991a5..8c14de00f7 100644
--- a/src/inputmethod.cpp
+++ b/src/inputmethod.cpp
@@ -550,18 +550,18 @@ void InputMethod::keysymReceived(quint32 serial, quint32 time, quint32 sym, bool
 void InputMethod::commitString(qint32 serial, const QString &text)
 {
     if (auto t1 = waylandServer()->seat()->textInputV1(); t1 && t1->isEnabled()) {
-        t1->commitString(text.toUtf8());
+        t1->commitString(text);
         t1->setPreEditCursor(0);
         t1->preEdit({}, {});
         return;
     }
     if (auto t2 = waylandServer()->seat()->textInputV2(); t2 && t2->isEnabled()) {
-        t2->commitString(text.toUtf8());
+        t2->commitString(text);
         t2->setPreEditCursor(0);
         t2->preEdit({}, {});
         return;
     } else if (auto t3 = waylandServer()->seat()->textInputV3(); t3 && t3->isEnabled()) {
-        t3->commitString(text.toUtf8());
+        t3->commitString(text);
         t3->done();
         return;
     } else {
@@ -641,11 +641,11 @@ void InputMethod::setLanguage(uint32_t serial, const QString &language)
 {
     auto t1 = waylandServer()->seat()->textInputV1();
     if (t1 && t1->isEnabled()) {
-        t1->setLanguage(language.toUtf8());
+        t1->setLanguage(language);
     }
     auto t2 = waylandServer()->seat()->textInputV2();
     if (t2 && t2->isEnabled()) {
-        t2->setLanguage(language.toUtf8());
+        t2->setLanguage(language);
     }
 }
 
@@ -700,11 +700,11 @@ void InputMethod::setPreeditString(uint32_t serial, const QString &text, const Q
 {
     auto t1 = waylandServer()->seat()->textInputV1();
     if (t1 && t1->isEnabled()) {
-        t1->preEdit(text.toUtf8(), commit.toUtf8());
+        t1->preEdit(text, commit);
     }
     auto t2 = waylandServer()->seat()->textInputV2();
     if (t2 && t2->isEnabled()) {
-        t2->preEdit(text.toUtf8(), commit.toUtf8());
+        t2->preEdit(text, commit);
     }
     auto t3 = waylandServer()->seat()->textInputV3();
     if (t3 && t3->isEnabled()) {
@@ -899,12 +899,12 @@ void InputMethod::startInputMethod()
     socket = dup(socket);
 
     QProcessEnvironment environment = kwinApp()->processStartupEnvironment();
-    environment.insert(QStringLiteral("WAYLAND_SOCKET"), QByteArray::number(socket));
+    environment.insert(QStringLiteral("WAYLAND_SOCKET"), QString::number(socket));
     environment.insert(QStringLiteral("QT_QPA_PLATFORM"), QStringLiteral("wayland"));
     // When we use Maliit as virtual keyboard, we want KWin to handle the animation
     // since that works a lot better. So we need to tell Maliit to not do client side
     // animation.
-    environment.insert(QStringLiteral("MALIIT_ENABLE_ANIMATIONS"), "0");
+    environment.insert(QStringLiteral("MALIIT_ENABLE_ANIMATIONS"), QStringLiteral("0"));
 
     m_inputMethodProcess = new QProcess(this);
     m_inputMethodProcess->setProcessChannelMode(QProcess::ForwardedErrorChannel);
-- 
2.45.2

From 90824cce9d652baf3ee771f55ba3c889fbdde01b Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 17 Jun 2024 20:20:49 +0000
Subject: [PATCH 13/17] Remove code that updates the focus chain in
 Window::setSkipTaskbar()

skipsTaskbar() doesn't influence whether the window wants input.


(cherry picked from commit 7fca508619bd5702889b8cff1a7ad859e6dca25d)

Co-authored-by: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
---
 src/window.cpp | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/window.cpp b/src/window.cpp
index f640c89381..1ca7472415 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -453,16 +453,12 @@ void Window::doSetSkipPager()
 
 void Window::setSkipTaskbar(bool b)
 {
-    int was_wants_tab_focus = wantsTabFocus();
     if (b == skipTaskbar()) {
         return;
     }
     m_skipTaskbar = b;
     doSetSkipTaskbar();
     updateWindowRules(Rules::SkipTaskbar);
-    if (was_wants_tab_focus != wantsTabFocus()) {
-        Workspace::self()->focusChain()->update(this, isActive() ? FocusChain::MakeFirst : FocusChain::Update);
-    }
     Q_EMIT skipTaskbarChanged();
 }
 
-- 
2.45.2

From 7c457506882653c7ef10c3722c9253bac58e9e02 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Tue, 18 Jun 2024 07:51:19 +0000
Subject: [PATCH 14/17] Sync xwayland eavesdropping default in kwin.kcfg

Amends a136a159f92a41cce749eb96b5f4e8c61265c1c3 which changed the value in the kcfg file that the kcm reads, KWin uses options.kcfg
4f322e24d35c6385ba2806d723c638102824c01c changed the in code default but this will be later overriden when loading the options.


(cherry picked from commit 1b1af29de9d7687436368a54a5e6344874f1eebc)

Co-authored-by: David Redondo <kde@david-redondo.de>
---
 src/kwin.kcfg | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/kwin.kcfg b/src/kwin.kcfg
index 0945be128e..9a6759382e 100644
--- a/src/kwin.kcfg
+++ b/src/kwin.kcfg
@@ -344,7 +344,7 @@
                 <choice name="Combinations"/>
                 <choice name="All"/>
             </choices>
-            <default>None</default>
+            <default>Combinations</default>
         </entry>
         <entry name="XwaylandEavesdropsMouse" type="Bool">
             <default>false</default>
-- 
2.45.2

From e8ea19c753a0785b143f13b17605ad2e28a00f31 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Thu, 13 Jun 2024 16:48:38 +0200
Subject: [PATCH 15/17] workspace: also update xwayland scale when not changing
 the output order

(cherry picked from commit 4f5fce8b7aa723eaa4d9f1185341a1af4f1dba99)
---
 src/workspace.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/workspace.cpp b/src/workspace.cpp
index db3a365a19..3e55b11581 100644
--- a/src/workspace.cpp
+++ b/src/workspace.cpp
@@ -496,13 +496,13 @@ bool Workspace::applyOutputConfiguration(const OutputConfiguration &config, cons
         return false;
     }
     updateOutputs(outputOrder);
-    m_outputConfigStore->storeConfig(kwinApp()->outputBackend()->outputs(), m_lidSwitchTracker->isLidClosed(), config, outputOrder);
+    m_outputConfigStore->storeConfig(kwinApp()->outputBackend()->outputs(), m_lidSwitchTracker->isLidClosed(), config, m_outputOrder);
     KConfig cfg(QStringLiteral("kdeglobals"));
     KConfigGroup kscreenGroup = cfg.group(QStringLiteral("KScreen"));
     const bool xwaylandClientsScale = kscreenGroup.readEntry("XwaylandClientsScale", true);
-    if (xwaylandClientsScale && !outputOrder.isEmpty()) {
+    if (xwaylandClientsScale && !m_outputOrder.isEmpty()) {
         double maxScale = 0;
-        for (Output *output : outputOrder) {
+        for (Output *output : m_outputOrder) {
             const auto changeset = config.constChangeSet(output);
             maxScale = std::max(maxScale, changeset ? changeset->scale.value_or(output->scale()) : output->scale());
         }
-- 
2.45.2

From 0df8a8d3fe92379d9972c3169fe918eb7389eb44 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Wed, 12 Jun 2024 16:16:54 +0200
Subject: [PATCH 16/17] autotests: add Xwayland scale changes to the output
 changes test

CCBUG: 487409
(cherry picked from commit e16069ae77cbacaeae1db9bca6641918ae3ada5e)
---
 autotests/integration/CMakeLists.txt         |  2 +-
 autotests/integration/outputchanges_test.cpp | 78 ++++++++++++++++++++
 2 files changed, 79 insertions(+), 1 deletion(-)

diff --git a/autotests/integration/CMakeLists.txt b/autotests/integration/CMakeLists.txt
index 1fea5bada7..3a5a9b62af 100644
--- a/autotests/integration/CMakeLists.txt
+++ b/autotests/integration/CMakeLists.txt
@@ -144,7 +144,7 @@ integrationTest(NAME testActivation SRCS activation_test.cpp)
 integrationTest(NAME testInputMethod SRCS inputmethod_test.cpp LIBS XKB::XKB)
 integrationTest(NAME testScreens SRCS screens_test.cpp)
 integrationTest(NAME testScreenEdges SRCS screenedges_test.cpp LIBS XCB::ICCCM)
-integrationTest(NAME testOutputChanges SRCS outputchanges_test.cpp)
+integrationTest(NAME testOutputChanges SRCS outputchanges_test.cpp LIBS XCB::ICCCM)
 integrationTest(NAME testTiles SRCS tiles_test.cpp)
 integrationTest(NAME testFractionalScaling SRCS fractional_scaling_test.cpp)
 integrationTest(NAME testMoveResize SRCS move_resize_window_test.cpp LIBS XCB::ICCCM)
diff --git a/autotests/integration/outputchanges_test.cpp b/autotests/integration/outputchanges_test.cpp
index 7977f7b179..26f584e6ee 100644
--- a/autotests/integration/outputchanges_test.cpp
+++ b/autotests/integration/outputchanges_test.cpp
@@ -14,8 +14,11 @@
 #include "wayland_server.h"
 #include "window.h"
 #include "workspace.h"
+#include "x11window.h"
 
 #include <KWayland/Client/surface.h>
+#include <netwm.h>
+#include <xcb/xcb_icccm.h>
 
 using namespace std::chrono_literals;
 
@@ -51,6 +54,7 @@ private Q_SLOTS:
     void testInvalidGeometryRestoreAfterEnablingOutput();
     void testMaximizedWindowDoesntDisappear_data();
     void testMaximizedWindowDoesntDisappear();
+    void testXwaylandScaleChange();
 
     void testWindowNotRestoredAfterMovingWindowAndEnablingOutput();
     void testLaptopLidClosed();
@@ -1004,6 +1008,80 @@ void OutputChangesTest::testLaptopLidClosed()
     input()->removeInputDevice(lidSwitch.get());
 }
 
+static X11Window *createX11Window(xcb_connection_t *connection, const QRect &geometry, std::function<void(xcb_window_t)> setup = {})
+{
+    xcb_window_t windowId = xcb_generate_id(connection);
+    xcb_create_window(connection, XCB_COPY_FROM_PARENT, windowId, rootWindow(),
+                      geometry.x(),
+                      geometry.y(),
+                      geometry.width(),
+                      geometry.height(),
+                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, XCB_COPY_FROM_PARENT, 0, nullptr);
+
+    xcb_size_hints_t hints;
+    memset(&hints, 0, sizeof(hints));
+    xcb_icccm_size_hints_set_position(&hints, 1, geometry.x(), geometry.y());
+    xcb_icccm_size_hints_set_size(&hints, 1, geometry.width(), geometry.height());
+    xcb_icccm_set_wm_normal_hints(connection, windowId, &hints);
+
+    if (setup) {
+        setup(windowId);
+    }
+
+    xcb_map_window(connection, windowId);
+    xcb_flush(connection);
+
+    QSignalSpy windowCreatedSpy(workspace(), &Workspace::windowAdded);
+    if (!windowCreatedSpy.wait()) {
+        return nullptr;
+    }
+    return windowCreatedSpy.last().first().value<X11Window *>();
+}
+
+void OutputChangesTest::testXwaylandScaleChange()
+{
+    Test::setOutputConfig({
+        QRect(0, 0, 1280, 1024),
+        QRect(1280, 0, 1280, 1024),
+    });
+    const auto outputs = workspace()->outputs();
+
+    {
+        OutputConfiguration config;
+        config.changeSet(outputs[0])->scale = 2;
+        config.changeSet(outputs[1])->scale = 1;
+        workspace()->applyOutputConfiguration(config);
+    }
+    QCOMPARE(kwinApp()->xwaylandScale(), 2);
+
+    Test::XcbConnectionPtr c = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(c.get()));
+    X11Window *window = createX11Window(c.get(), QRect(0, 0, 100, 200));
+    const QRectF originalGeometry = window->frameGeometry();
+
+    // disable the left output -> window gets moved to the right output
+    {
+        OutputConfiguration config;
+        config.changeSet(outputs[0])->enabled = false;
+        workspace()->applyOutputConfiguration(config);
+    }
+
+    // the window should still have logical size of 100, 200
+    QCOMPARE(kwinApp()->xwaylandScale(), 1);
+    QCOMPARE(window->frameGeometry().size(), originalGeometry.size());
+
+    // enable the left output again
+    {
+        OutputConfiguration config;
+        config.changeSet(outputs[0])->enabled = true;
+        workspace()->applyOutputConfiguration(config);
+    }
+
+    // the window should be back in its original geometry
+    QCOMPARE(kwinApp()->xwaylandScale(), 2);
+    QCOMPARE(window->frameGeometry(), originalGeometry);
+}
+
 } // namespace KWin
 
 WAYLANDTEST_MAIN(KWin::OutputChangesTest)
-- 
2.45.2

From 63b68d6961b3e5a324143d96c2129558b3bb4c88 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Wed, 19 Jun 2024 12:11:23 +0000
Subject: [PATCH 17/17] plugins/eis: Make input capture activation ids unsigned

The portal API is specified with unsigned ids. Let's make them
unsigned all the way through.


(cherry picked from commit 1a916293dc8a33c980d3110a2ce34dde98406659)

Co-authored-by: David Redondo <kde@david-redondo.de>
---
 src/plugins/eis/eisinputcapture.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/plugins/eis/eisinputcapture.h b/src/plugins/eis/eisinputcapture.h
index 7fdd1cbb14..e9381f02de 100644
--- a/src/plugins/eis/eisinputcapture.h
+++ b/src/plugins/eis/eisinputcapture.h
@@ -47,8 +47,8 @@ public:
     Q_INVOKABLE void release(const QPointF &cursorPosition, bool applyPosition);
 Q_SIGNALS:
     void disabled();
-    void activated(int activationId, const QPointF &cursorPosition);
-    void deactivated(int activationId);
+    void activated(uint activationId, const QPointF &cursorPosition);
+    void deactivated(uint activationId);
 
 private:
     void handleEvents();
@@ -66,7 +66,7 @@ private:
     eis_device *m_pointer = nullptr;
     eis_device *m_keyboard = nullptr;
     eis_device *m_absoluteDevice = nullptr;
-    int m_activationId = 0;
+    uint m_activationId = 0;
 };
 
 }
-- 
2.45.2

