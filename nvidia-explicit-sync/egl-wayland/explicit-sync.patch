From ba39127e68299fb9ccfcad5f5cb8531011fa10a9 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Wed, 21 Feb 2024 10:46:02 -0500
Subject: [PATCH] egl-wayland: implement linux-drm-syncobj-v1

This implements the explicit sync linux-drm-syncobj-v1 protocol for EGL.

Most of this change involves wayland-protocol handling boilerplate. The
protocol works by allowing the creation of timelines (i.e. DRM syncobjs)
and per-surface states. We can then specify acquire and release points
during our surface state configuration which will tell the compositor
when it can access the buffer or notify us when it is finished accessing
the buffer.

Sync point signaling takes place during acquire_surface_image. We choose
our two release point values and send them to the compositor.  In the
acquire case, the EGLSync will be created first and will be populated
with a fence representing the GPU work. We can extract its syncfd and
import it at the acquire point. We choose the release point during
image acquisition, but don't actually create an EGLSync for it until
later when the compositor has added a fence to the release point. We
check if this has taken place after every surface commit.

Separate timelines are used for the acquire and release points. Each
stream image will have its own timeline, otherwise our signaling of
acquire points would implicitly signal the still-pending release points.
---
 include/wayland-egldisplay.h          |   4 +
 include/wayland-eglhandle.h           |   2 +
 include/wayland-eglsurface-internal.h |  20 +
 src/meson.build                       |   4 +
 src/wayland-egldisplay.c              |  23 ++
 src/wayland-eglhandle.c               |   2 +
 src/wayland-eglsurface.c              | 514 ++++++++++++++++++++++++--
 src/wayland-eglswap.c                 |   1 +
 8 files changed, 535 insertions(+), 35 deletions(-)

diff --git a/include/wayland-egldisplay.h b/include/wayland-egldisplay.h
index e038668..8e02ed0 100644
--- a/include/wayland-egldisplay.h
+++ b/include/wayland-egldisplay.h
@@ -128,6 +128,7 @@ typedef struct WlEglDisplayRec {
     struct wl_eglstream_display    *wlStreamDpy;
     struct wl_eglstream_controller *wlStreamCtl;
     struct zwp_linux_dmabuf_v1     *wlDmaBuf;
+    struct wp_linux_drm_syncobj_manager_v1 *wlDrmSyncobj;
     unsigned int                    wlStreamCtlVer;
     struct wp_presentation         *wpPresentation;
     struct wl_event_queue          *wlEventQueue;
@@ -139,6 +140,9 @@ typedef struct WlEglDisplayRec {
 
     WlEglPlatformData *data;
 
+    /* DRM device in use */
+    int drmFd;
+
     EGLBoolean useInitRefCount;
     EGLDeviceEXT requestedDevice;
 
diff --git a/include/wayland-eglhandle.h b/include/wayland-eglhandle.h
index bd8abaf..9e694f9 100644
--- a/include/wayland-eglhandle.h
+++ b/include/wayland-eglhandle.h
@@ -108,7 +108,9 @@ typedef struct WlEglPlatformDataRec {
         PFNEGLCLIENTWAITSYNCKHRPROC                 clientWaitSync;
         PFNEGLSIGNALSYNCKHRPROC                     signalSync;
         PFNEGLDESTROYSYNCKHRPROC                    destroySync;
+        PFNEGLCREATESYNCKHRPROC                     createSync;
         PFNEGLSTREAMFLUSHNVPROC                     streamFlush;
+        PFNEGLDUPNATIVEFENCEFDANDROIDPROC           dupNativeFenceFD;
 
         /* Used for dma-buf surfaces */
         PFNEGLSTREAMIMAGECONSUMERCONNECTNVPROC      streamImageConsumerConnect;
diff --git a/include/wayland-eglsurface-internal.h b/include/wayland-eglsurface-internal.h
index 3af8829..ee6edae 100644
--- a/include/wayland-eglsurface-internal.h
+++ b/include/wayland-eglsurface-internal.h
@@ -51,6 +51,15 @@ typedef struct WlEglStreamImageRec {
     struct wl_buffer       *buffer;
     EGLBoolean              attached;
     struct wl_list          acquiredLink;
+
+    struct wp_linux_drm_syncobj_timeline_v1 *wlReleaseTimeline;
+    int                     drmSyncobjFd;
+    uint32_t                drmSyncobjHandle;
+    int                     releasePending;
+    /* Latest release point the compositor will signal with explicit sync */
+    uint64_t                releasePoint;
+    /* Cached acquire EGLSync from acquireImage */
+    EGLSyncKHR              acquireSync;
 } WlEglStreamImage;
 
 typedef struct WlEglSurfaceCtxRec {
@@ -151,6 +160,14 @@ struct WlEglSurfaceRec {
     EGLBoolean isResized;
 
     WlEglDmaBufFeedback feedback;
+
+    /* per-surface Explicit Sync objects */
+    struct wp_linux_drm_syncobj_surface_v1 *wlSyncobjSurf;
+    struct wp_linux_drm_syncobj_timeline_v1 *wlAcquireTimeline;
+    int drmSyncobjFd;
+    uint32_t drmSyncobjHandle;
+    /* Last acquire point used. This starts at 1, zero means invalid.  */
+    uint64_t syncPoint;
 };
 
 void wlEglReallocSurface(WlEglDisplay *display,
@@ -185,6 +202,9 @@ EGLBoolean wlEglQueryNativeResourceHook(EGLDisplay dpy,
                                         EGLint attribute,
                                         int *value);
 
+EGLBoolean
+wlEglSurfaceCheckReleasePoints(WlEglDisplay *display, WlEglSurface *surface);
+
 EGLBoolean wlEglSendDamageEvent(WlEglSurface *surface,
                                 struct wl_event_queue *queue);
 
diff --git a/src/meson.build b/src/meson.build
index 56d075b..5a5e4e0 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -19,6 +19,7 @@ libdrm = dependency('libdrm')
 wl_protos_dir = wl_protos.get_pkgconfig_variable('pkgdatadir')
 wl_dmabuf_xml = join_paths(wl_protos_dir, 'unstable', 'linux-dmabuf', 'linux-dmabuf-unstable-v1.xml')
 wp_presentation_time_xml = join_paths(wl_protos_dir, 'stable', 'presentation-time', 'presentation-time.xml')
+wl_drm_syncobj_xml = join_paths(wl_protos_dir, 'staging', 'linux-drm-syncobj', 'linux-drm-syncobj-v1.xml')
 
 client_header = generator(prog_scanner,
     output : '@BASENAME@-client-protocol.h',
@@ -65,6 +66,9 @@ src += code.process(wl_dmabuf_xml)
 src += client_header.process(wp_presentation_time_xml)
 src += code.process(wp_presentation_time_xml)
 
+src += client_header.process(wl_drm_syncobj_xml)
+src += code.process(wl_drm_syncobj_xml)
+
 egl_wayland = library('nvidia-egl-wayland',
     src,
     dependencies : [
diff --git a/src/wayland-egldisplay.c b/src/wayland-egldisplay.c
index a72c3f4..72bbddc 100644
--- a/src/wayland-egldisplay.c
+++ b/src/wayland-egldisplay.c
@@ -32,6 +32,7 @@
 #include "wayland-drm-client-protocol.h"
 #include "wayland-drm.h"
 #include "presentation-time-client-protocol.h"
+#include "linux-drm-syncobj-v1-client-protocol.h"
 #include <string.h>
 #include <stdlib.h>
 #include <assert.h>
@@ -454,6 +455,11 @@ registry_handle_global(void *data,
                                                    name,
                                                    &wp_presentation_interface,
                                                    version);
+    } else if (strcmp(interface, "wp_linux_drm_syncobj_manager_v1") == 0) {
+        display->wlDrmSyncobj = wl_registry_bind(registry,
+                                                 name,
+                                                 &wp_linux_drm_syncobj_manager_v1_interface,
+                                                 version);
     }
 }
 
@@ -738,6 +744,10 @@ static EGLBoolean terminateDisplay(WlEglDisplay *display, EGLBoolean globalTeard
             wp_presentation_destroy(display->wpPresentation);
             display->wpPresentation = NULL;
         }
+        if (display->wlDrmSyncobj) {
+            wp_linux_drm_syncobj_manager_v1_destroy(display->wlDrmSyncobj);
+            display->wlDrmSyncobj = NULL;
+        }
         if (display->wlDmaBuf) {
             zwp_linux_dmabuf_v1_destroy(display->wlDmaBuf);
             display->wlDmaBuf = NULL;
@@ -926,6 +936,7 @@ EGLDisplay wlEglGetPlatformDisplayExport(void *data,
     EGLDeviceEXT requestedDevice = EGL_NO_DEVICE_EXT;
     EGLBoolean usePrimeRenderOffload = EGL_FALSE;
     EGLBoolean isServerNV;
+    const char *drmName = NULL;
 
     if (platform != EGL_PLATFORM_WAYLAND_EXT) {
         wlEglSetError(data, EGL_BAD_PARAMETER);
@@ -1168,6 +1179,17 @@ EGLDisplay wlEglGetPlatformDisplayExport(void *data,
     display->refCount = 1;
     WL_LIST_INIT(&display->wlEglSurfaceList);
 
+    /* Get the DRM device in use */
+    drmName = display->data->egl.queryDeviceString(display->devDpy->eglDevice,
+                                                   EGL_DRM_DEVICE_FILE_EXT);
+    if (!drmName) {
+        goto fail;
+    }
+
+    display->drmFd = open(drmName, O_RDWR);
+    if (display->drmFd < 0) {
+        goto fail;
+    }
 
     // The newly created WlEglDisplay has been set up properly, insert it
     // in wlEglDisplayList.
@@ -1353,6 +1375,7 @@ WlEglDisplay *wlEglAcquireDisplay(EGLDisplay dpy) {
 static void wlEglUnrefDisplay(WlEglDisplay *display) {
     if (--display->refCount == 0) {
         wlEglMutexDestroy(&display->mutex);
+        close(display->drmFd);
         free(display);
     }
 }
diff --git a/src/wayland-eglhandle.c b/src/wayland-eglhandle.c
index e0080f1..df01d6e 100644
--- a/src/wayland-eglhandle.c
+++ b/src/wayland-eglhandle.c
@@ -111,6 +111,8 @@ wlEglCreatePlatformData(int apiMajor, int apiMinor, const EGLExtDriver *driver)
     GET_PROC(clientWaitSync,              eglClientWaitSyncKHR);
     GET_PROC(signalSync,                  eglSignalSyncKHR);
     GET_PROC(destroySync,                 eglDestroySyncKHR);
+    GET_PROC(createSync,                  eglCreateSyncKHR);
+    GET_PROC(dupNativeFenceFD,            eglDupNativeFenceFDANDROID);
 
     /* Stream flush */
     GET_PROC(streamFlush,                 eglStreamFlushNV);
diff --git a/src/wayland-eglsurface.c b/src/wayland-eglsurface.c
index 98f38cf..cf91815 100644
--- a/src/wayland-eglsurface.c
+++ b/src/wayland-eglsurface.c
@@ -24,6 +24,7 @@
 #include "wayland-eglstream-client-protocol.h"
 #include "wayland-eglstream-controller-client-protocol.h"
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "linux-drm-syncobj-v1-client-protocol.h"
 #include "wayland-eglstream-server.h"
 #include "wayland-thread.h"
 #include "wayland-eglutils.h"
@@ -42,6 +43,8 @@
 #include <errno.h>
 #include <libdrm/drm_fourcc.h>
 #include <sys/stat.h>
+#include <xf86drm.h>
+#include <stdio.h>
 
 #define WL_EGL_WINDOW_DESTROY_CALLBACK_SINCE 3
 
@@ -154,10 +157,108 @@ EGLint wlEglWaitFrameSync(WlEglSurface *surface)
     return EGL_SUCCESS;
 }
 
+static bool
+syncobj_import_fd_to_current_point(WlEglDisplay *display, WlEglSurface *surface,
+                                   int syncFd)
+{
+    bool                ret = false;
+    uint32_t            tmpSyncobj;
+
+    /* Import our syncfd at a new release point */
+    if (drmSyncobjCreate(display->drmFd, 0, &tmpSyncobj) != 0) {
+        return false;
+    }
+
+    if (drmSyncobjImportSyncFile(display->drmFd, tmpSyncobj, syncFd) != 0) {
+        goto end;
+    }
+
+    if (drmSyncobjTransfer(display->drmFd, surface->drmSyncobjHandle,
+                           surface->syncPoint, tmpSyncobj, 0, 0) != 0) {
+        goto end;
+    }
+
+    ret = true;
+
+end:
+    drmSyncobjDestroy(display->drmFd, tmpSyncobj);
+
+    return ret;
+}
+
+static bool
+send_explicit_sync_points (WlEglDisplay *display, WlEglSurface *surface,
+                           WlEglStreamImage *image)
+{
+    WlEglPlatformData  *data        = display->data;
+    EGLDisplay          dpy         = display->devDpy->eglDisplay;
+    struct wp_linux_drm_syncobj_surface_v1 *syncobj_wrapper = NULL;
+    struct wp_linux_drm_syncobj_timeline_v1 *acquire_timeline, *release_timeline;
+    int                 syncFd, err;
+    uint64_t            acquireSyncPoint;
+
+    /* Ignore this unless we are using Explicit Sync */
+    if (!surface->wlSyncobjSurf) {
+        return true;
+    }
+
+    /* --------------- Get acquire sync fd -------------- */
+    syncFd = data->egl.dupNativeFenceFD(dpy, image->acquireSync);
+    if (syncFd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+        return false;
+    }
+
+    /* Clean up our acquire sync object now that we are done with it */
+    data->egl.destroySync(dpy, image->acquireSync);
+    image->acquireSync = EGL_NO_SYNC_KHR;
+
+    err = syncobj_import_fd_to_current_point(display, surface, syncFd);
+    close(syncFd);
+    if (!err) {
+        return false;
+    }
+    acquireSyncPoint = surface->syncPoint++;
+
+    /* --------------- Get release EGLSyncKHR -------------- */
+
+    /* Increment to a new sync point here in the image. */
+    image->releasePoint++;
+    image->releasePending = true;
+
+    /* --------------- Send sync points -------------- */
+
+    /* Now notify the compositor of our next acquire point */
+    syncobj_wrapper = wl_proxy_create_wrapper(surface->wlSyncobjSurf);
+    wl_proxy_set_queue((struct wl_proxy *)syncobj_wrapper, surface->wlEventQueue);
+    acquire_timeline = wl_proxy_create_wrapper(surface->wlAcquireTimeline);
+    wl_proxy_set_queue((struct wl_proxy *)acquire_timeline, surface->wlEventQueue);
+    release_timeline = wl_proxy_create_wrapper(image->wlReleaseTimeline);
+    wl_proxy_set_queue((struct wl_proxy *)release_timeline, surface->wlEventQueue);
+
+    wp_linux_drm_syncobj_surface_v1_set_acquire_point(syncobj_wrapper,
+                                                      acquire_timeline,
+                                                      acquireSyncPoint >> 32,
+                                                      acquireSyncPoint & 0xffffffff);
+
+    /* Now notify the compositor of our next release point */
+    wp_linux_drm_syncobj_surface_v1_set_release_point(syncobj_wrapper,
+                                                      release_timeline,
+                                                      image->releasePoint >> 32,
+                                                      image->releasePoint & 0xffffffff);
+
+    wl_proxy_wrapper_destroy(syncobj_wrapper);
+    wl_proxy_wrapper_destroy(acquire_timeline);
+    wl_proxy_wrapper_destroy(release_timeline);
+
+    return true;
+}
+
 EGLBoolean
 wlEglSendDamageEvent(WlEglSurface *surface, struct wl_event_queue *queue)
 {
     struct wl_display *wlDpy = surface->wlEglDpy->nativeDpy;
+    struct wl_surface *wrapper = wl_proxy_create_wrapper(surface->wlSurface);
+    wl_proxy_set_queue((struct wl_proxy *)wrapper, queue);
 
     if (surface->ctx.wlStreamResource) {
         /* Attach same buffer to indicate new content for the surface is
@@ -168,8 +269,8 @@ wlEglSendDamageEvent(WlEglSurface *surface, struct wl_event_queue *queue)
                           surface->dy);
     } else {
         WlEglStreamImage *image;
-
         if (wlEglHandleImageStreamEvents(surface) != EGL_SUCCESS) {
+            wl_proxy_wrapper_destroy(wrapper);
             return EGL_FALSE;
         }
 
@@ -179,17 +280,29 @@ wlEglSendDamageEvent(WlEglSurface *surface, struct wl_event_queue *queue)
             image->attached = EGL_TRUE;
         }
 
-        wl_surface_attach(surface->wlSurface,
+        wl_surface_attach(wrapper,
                           surface->ctx.currentBuffer,
                           surface->dx,
                           surface->dy);
+
+        /*
+         * Send our explicit sync acquire and release points. This needs to be done
+         * as part of the surface attach as it is a protocol error to specify these
+         * points without attaching a buffer in the same commit.
+         */
+        if (!send_explicit_sync_points(surface->wlEglDpy, surface, image)) {
+            wl_proxy_wrapper_destroy(wrapper);
+            return EGL_FALSE;
+        }
     }
 
-    wl_surface_damage(surface->wlSurface, 0, 0,
+    wl_surface_damage(wrapper, 0, 0,
                       surface->width, surface->height);
-    wl_surface_commit(surface->wlSurface);
+    wl_surface_commit(wrapper);
     surface->ctx.isAttached = EGL_TRUE;
 
+    wl_proxy_wrapper_destroy(wrapper);
+
     return (wl_display_roundtrip_queue(wlDpy,
                                        queue) >= 0) ? EGL_TRUE : EGL_FALSE;
 }
@@ -473,6 +586,7 @@ destroy_stream_image(WlEglDisplay *display,
     assert(image->eglImage != EGL_NO_IMAGE_KHR);
     data->egl.destroyImage(dpy, image->eglImage);
     image->eglImage = EGL_NO_IMAGE_KHR;
+    image->releasePoint = 0;
 
     if (surface->ctx.currentBuffer == image->buffer) {
         surface->ctx.currentBuffer = NULL;
@@ -487,6 +601,17 @@ destroy_stream_image(WlEglDisplay *display,
         wl_list_remove(&image->acquiredLink);
         wl_list_init(&image->acquiredLink);
     }
+
+    if (image->wlReleaseTimeline) {
+        wp_linux_drm_syncobj_timeline_v1_destroy(image->wlReleaseTimeline);
+        drmSyncobjDestroy(display->drmFd, image->drmSyncobjHandle);
+        if (image->acquireSync != EGL_NO_SYNC_KHR) {
+            data->egl.destroySync(dpy, image->acquireSync);
+            image->acquireSync = EGL_NO_SYNC_KHR;
+        }
+        close(surface->drmSyncobjFd);
+        image->releasePending = false;
+    }
 }
 
 static void
@@ -938,10 +1063,19 @@ stream_local_buffer_release_callback(void *ptr, struct wl_buffer *buffer)
     image->attached = EGL_FALSE;
 
     if (image->eglImage != EGL_NO_IMAGE_KHR) {
-        data->egl.streamReleaseImage(display->devDpy->eglDisplay,
-                                     surface->ctx.eglStream,
-                                     image->eglImage,
-                                     EGL_NO_SYNC_KHR);
+        /*
+         * Release our image back to the stream if explicit sync is not in use
+         *
+         * If explicit sync was used, then wl_buffer.release means nothing. We
+         * will instead have already marked this image for release contingent
+         * on the release sync getting signaled.
+         */
+        if (!surface->wlSyncobjSurf) {
+            data->egl.streamReleaseImage(display->devDpy->eglDisplay,
+                                         surface->ctx.eglStream,
+                                         image->eglImage,
+                                         EGL_NO_SYNC_KHR);
+        }
     } else if (image->buffer) {
         /*
          * If the image has been destroyed while the buffer was attached
@@ -958,6 +1092,174 @@ static const struct wl_buffer_listener stream_local_buffer_listener = {
     stream_local_buffer_release_callback,
 };
 
+/*
+ * Export a syncfd from the timeline at the specified point and make an
+ * EGLSyncKHR out of it.  We can then pass this eglsync to releaseImageNV and
+ * it will wait for the release point to signal before releasing the image back
+ * to the screen.
+ */
+static EGLSyncKHR
+get_release_sync(WlEglDisplay *display, WlEglStreamImage *image)
+{
+    EGLDisplay          dpy         = display->devDpy->eglDisplay;
+    WlEglPlatformData  *data        = display->data;
+    EGLSyncKHR          eglSync     = EGL_NO_SYNC_KHR;
+    int                 syncFd      = -1;
+    uint32_t            tmpSyncobj;
+    EGLint              attribs[3];
+
+
+    /* Import our acquire syncfd at a new acquire point */
+    if (drmSyncobjCreate(display->drmFd, 0, &tmpSyncobj) != 0) {
+        return EGL_NO_SYNC_KHR;
+    }
+
+    if (drmSyncobjTransfer(display->drmFd, tmpSyncobj, 0,
+                           image->drmSyncobjHandle, image->releasePoint,
+                           0) != 0) {
+        goto destroy;
+    }
+
+    if (drmSyncobjExportSyncFile(display->drmFd, tmpSyncobj,
+                                 &syncFd) != 0) {
+        goto destroy;
+    }
+
+    attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+    attribs[1] = syncFd;
+    attribs[2] = EGL_NONE;
+    eglSync = data->egl.createSync(dpy, EGL_SYNC_NATIVE_FENCE_ANDROID,
+                                   attribs);
+    close (syncFd);
+destroy:
+    drmSyncobjDestroy(display->drmFd, tmpSyncobj);
+
+    return eglSync;
+}
+
+/*
+ * We have committed a frame, and if we are using explicit sync
+ * we will have registered a release point with the compositor.
+ * The release point's fence didn't exist then, so we should check
+ * for any available fences that we should trigger releasing
+ * images back into the stream with.
+ *
+ * This will block if no available buffers have been released.
+ */
+EGLBoolean
+wlEglSurfaceCheckReleasePoints(WlEglDisplay *display, WlEglSurface *surface)
+{
+    WlEglPlatformData  *data        = display->data;
+    EGLDisplay          dpy         = display->devDpy->eglDisplay;
+    EGLSyncKHR          releaseSync = EGL_NO_SYNC_KHR;
+    WlEglStreamImage   *image = NULL;
+    uint32_t           *syncobjs;
+    uint64_t           *syncPoints;
+    uint32_t            i, firstSignaled, numSyncPoints = 0;
+    int64_t             timeout;
+    EGLBoolean          ret = EGL_FALSE;
+
+    if (!surface->wlSyncobjSurf) {
+        return EGL_TRUE;
+    }
+
+    syncobjs = calloc(surface->ctx.numStreamImages, sizeof(uint32_t));
+    syncPoints = calloc(surface->ctx.numStreamImages, sizeof(uint64_t));
+    if (!syncobjs || !syncPoints) {
+        return EGL_FALSE;
+    }
+
+    for (i = 0; i < surface->ctx.numStreamImages; i++) {
+        pthread_mutex_lock(&surface->ctx.streamImages[i]->mutex);
+    }
+
+    /* record each release point we are waiting on */
+    for (i = 0; i < surface->ctx.numStreamImages; i++) {
+        syncobjs[i] = surface->ctx.streamImages[i]->drmSyncobjHandle;
+
+        if (surface->ctx.streamImages[i]->releasePending) {
+            syncPoints[i] = surface->ctx.streamImages[i]->releasePoint;
+            numSyncPoints++;
+        } else {
+            /*
+             * Use a bogus point for acquired images so we can keep our indices
+             * the same. This won't affect anything since it will never have a fence
+             * appear.
+             */
+            syncPoints[i] = UINT64_MAX;
+        }
+    }
+
+    if (numSyncPoints == 0) {
+        goto end;
+    }
+
+    /*
+     * Wait for at least on release point to have a fence. We need to block here
+     * since the streams internal code expects to have at least one buffer placed
+     * back on the release (internally called returns) queue.
+     *
+     * We only wait indefinitely when there are at least two buffers pending.
+     * One of the pending buffers will be in use by the compositor, and the
+     * other should have its release point signaled. Without this we might block
+     * after the first buffer has been committed.
+     */
+    timeout = numSyncPoints >= 2 ? INT64_MAX : 0;
+
+    /*
+     * The Linux docs say that DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE should be
+     * used to wait for a fence to appear without waiting on the fence itself.
+     * Note that there are some bugs with certain kernels where this may not
+     * signal correctly.
+     */
+    if (drmSyncobjTimelineWait(display->drmFd, syncobjs, syncPoints,
+                               surface->ctx.numStreamImages, timeout,
+                               DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT,
+                               &firstSignaled) != 0) {
+        printf("wlEglSurfaceCheckReleasePoints: drmSyncobjTimelineWait failed with errno %d\n", errno);
+        goto end;
+    }
+
+    image = surface->ctx.streamImages[firstSignaled];
+
+    /* Try to get a release point for the first available buffer.  */
+    releaseSync = get_release_sync(display, image);
+    if (releaseSync == EGL_NO_SYNC_KHR) {
+        goto end;
+    }
+
+    /*
+     * Pass our newly created release EGLSyncKHR to our eglstream, it
+     * will wait for it to signal before it releases the image back to
+     * the stream. Note that wl_buffer.release means nothing with
+     * linux-drm-syncobj-v1.
+     */
+    ret = data->egl.streamReleaseImage(display->devDpy->eglDisplay,
+                                       surface->ctx.eglStream,
+                                       image->eglImage,
+                                       releaseSync);
+    /* releaseImage makes a copy, so we destroy ours here */
+    data->egl.destroySync(dpy, releaseSync);
+
+    /*
+     * If we succesfully released the image, Clear our release point so we
+     * don't repeat this.
+     */
+    if (ret == EGL_TRUE) {
+        image->releasePending = false;
+    }
+
+end:
+    for (i = 0; i < surface->ctx.numStreamImages; i++) {
+        pthread_mutex_unlock(&surface->ctx.streamImages[i]->mutex);
+    }
+
+    free(syncPoints);
+    free(syncobjs);
+
+    return ret;
+}
+
 static EGLint
 acquire_surface_image(WlEglDisplay *display, WlEglSurface *surface)
 {
@@ -974,12 +1276,33 @@ acquire_surface_image(WlEglDisplay *display, WlEglSurface *surface)
     EGLint              offset;
     uint32_t            i;
     int                 fd;
+    EGLSyncKHR          acquireSync = EGL_NO_SYNC_KHR;
+    const EGLint attribs[] = {
+        EGL_SYNC_NATIVE_FENCE_FD_ANDROID, EGL_NO_NATIVE_FENCE_FD_ANDROID,
+        EGL_SYNC_STATUS, EGL_SIGNALED,
+        EGL_NONE,
+    };
+
+    if (surface->wlSyncobjSurf) {
+        /*
+         * don't flush before acquireImage, we have to pass it in signaled.
+         *
+         * acquireImage will reset this, causing the fd to populate.
+         */
+        acquireSync = data->egl.createSync(dpy, EGL_SYNC_NATIVE_FENCE_ANDROID,
+                                           attribs);
+        if (acquireSync == EGL_NO_SYNC_KHR) {
+            return EGL_BAD_SURFACE;
+        }
+    }
 
     if (!data->egl.streamAcquireImage(dpy,
                                       surface->ctx.eglStream,
                                       &eglImage,
-                                      EGL_NO_SYNC_KHR)) {
-        return EGL_BAD_SURFACE;
+                                      acquireSync)) {
+        if (acquireSync != EGL_NO_SYNC_KHR) {
+            goto fail_destroy_sync;
+        }
     }
 
     for (i = 0; i < surface->ctx.numStreamImages; i++) {
@@ -990,11 +1313,13 @@ acquire_surface_image(WlEglDisplay *display, WlEglSurface *surface)
     }
 
     if (!image) {
-        goto fail_release;
+        goto fail_destroy_sync;
     }
 
     pthread_mutex_lock(&image->mutex);
 
+    image->acquireSync = acquireSync;
+
     if (!image->buffer) {
         if (!data->egl.exportDMABUFImageQuery(dpy,
                                               eglImage,
@@ -1081,12 +1406,23 @@ acquire_surface_image(WlEglDisplay *display, WlEglSurface *surface)
                                  eglImage,
                                  EGL_NO_SYNC_KHR);
 
+    if (image && image->acquireSync != EGL_NO_SYNC_KHR) {
+        data->egl.destroySync(dpy, image->acquireSync);
+        image->acquireSync = EGL_NO_SYNC_KHR;
+    }
+
     if (image) {
         /* Release the image lock */
         pthread_mutex_unlock(&image->mutex);
     }
 
     return EGL_BAD_SURFACE;
+
+fail_destroy_sync:
+    if (acquireSync != EGL_NO_SYNC_KHR) {
+        data->egl.destroySync(dpy, acquireSync);
+    }
+    return EGL_BAD_SURFACE;
 }
 
 static void
@@ -1126,33 +1462,86 @@ pop_acquired_image(WlEglSurface *surface)
 }
 
 static EGLint
-add_surface_image(WlEglDisplay *display, WlEglSurface *surface)
+init_surface_image(WlEglDisplay *display, WlEglSurface *surface,
+                   WlEglStreamImage    *image)
 {
     WlEglPlatformData   *data     = display->data;
     EGLDisplay           dpy      = display->devDpy->eglDisplay;
+
+    image->eglImage = data->egl.createImage(dpy, EGL_NO_CONTEXT,
+                                            EGL_STREAM_CONSUMER_IMAGE_NV,
+                                            (EGLClientBuffer)surface->ctx.eglStream,
+                                            NULL);
+    if (image->eglImage == EGL_NO_IMAGE_KHR) {
+        return EGL_BAD_ALLOC;
+    }
+
+    /*
+     * Create a per-stream image release timeline.
+     *
+     * This is needed since we will be the ones signaling acquire points. If the acquire points
+     * are on the same timeline as the release points then they will accidentally signal all
+     * pending release points.
+     */
+    if (surface->wlSyncobjSurf) {
+        struct wp_linux_drm_syncobj_manager_v1 *wrapper;
+
+        /* Create a DRM timeline and share it with the compositor */
+        if (drmSyncobjCreate(display->drmFd, 0, &image->drmSyncobjHandle)) {
+            goto fail;
+        }
+
+        if (drmSyncobjHandleToFD(display->drmFd, image->drmSyncobjHandle,
+                                 &image->drmSyncobjFd)) {
+            goto fail;
+        }
+        image->acquireSync = EGL_NO_SYNC_KHR;
+
+        /* Get a DRM timeline wl object */
+        wrapper = wl_proxy_create_wrapper(display->wlDrmSyncobj);
+        wl_proxy_set_queue((struct wl_proxy *)wrapper, surface->wlEventQueue);
+
+        image->wlReleaseTimeline =
+            wp_linux_drm_syncobj_manager_v1_import_timeline(wrapper, image->drmSyncobjFd);
+
+        wl_proxy_wrapper_destroy(wrapper);
+
+        if (!image->wlReleaseTimeline) {
+            goto fail;
+        }
+    }
+
+    return EGL_SUCCESS;
+
+fail:
+    if (image->drmSyncobjHandle) {
+        drmSyncobjDestroy(display->drmFd, image->drmSyncobjHandle);
+    }
+
+    if (image->drmSyncobjFd > 0) {
+        close(image->drmSyncobjFd);
+    }
+
+    data->egl.destroyImage(dpy, image->eglImage);
+    return EGL_BAD_ALLOC;
+}
+
+static EGLint
+add_surface_image(WlEglDisplay *display, WlEglSurface *surface)
+{
     WlEglStreamImage   **newImages;
     WlEglStreamImage    *image;
-    EGLImageKHR          eglImage;
+    EGLint               ret;
     uint32_t             i;
 
     for (i = 0; i < surface->ctx.numStreamImages; i++) {
         image = surface->ctx.streamImages[i];
         pthread_mutex_lock(&image->mutex);
         if ((image->eglImage == EGL_NO_IMAGE_KHR) && !image->buffer) {
-            eglImage = image->eglImage =
-                data->egl.createImage(dpy,
-                                      EGL_NO_CONTEXT,
-                                      EGL_STREAM_CONSUMER_IMAGE_NV,
-                                      (EGLClientBuffer)surface->ctx.eglStream,
-                                      NULL);
+            ret = init_surface_image(display, surface, image);
 
             pthread_mutex_unlock(&image->mutex);
-
-            if (eglImage != EGL_NO_IMAGE_KHR) {
-                return EGL_SUCCESS;
-            } else {
-                return EGL_BAD_ALLOC;
-            }
+            return ret;
         }
         pthread_mutex_unlock(&image->mutex);
     }
@@ -1187,14 +1576,8 @@ add_surface_image(WlEglDisplay *display, WlEglSurface *surface)
     }
 
     wl_list_init(&newImages[i]->acquiredLink);
-    newImages[i]->eglImage =
-        data->egl.createImage(dpy,
-                              EGL_NO_CONTEXT,
-                              EGL_STREAM_CONSUMER_IMAGE_NV,
-                              (EGLClientBuffer)surface->ctx.eglStream,
-                              NULL);
-
-    if (newImages[i]->eglImage == EGL_NO_IMAGE_KHR) {
+
+    if (init_surface_image(display, surface, newImages[i]) != EGL_SUCCESS) {
         wlEglMutexDestroy(&newImages[i]->mutex);
         goto free_image;
     }
@@ -1218,6 +1601,7 @@ EGLint wlEglHandleImageStreamEvents(WlEglSurface *surface)
     EGLAttrib             aux;
     EGLenum               event;
     EGLint                err = EGL_SUCCESS;
+    EGLint                timeout = surface->wlSyncobjSurf ? EGL_FOREVER : 0;
 
     if (surface->ctx.wlStreamResource) {
         /* Not a local stream */
@@ -1225,9 +1609,14 @@ EGLint wlEglHandleImageStreamEvents(WlEglSurface *surface)
     }
 
     while (1) {
+        /*
+         * With explicit sync we should block here and not return until we have
+         * acquired a new image. The stream will not release the image until
+         * the release point we handed to the compositor signals.
+         */
         err = data->egl.queryStreamConsumerEvent(dpy,
                                                  surface->ctx.eglStream,
-                                                 0,
+                                                 timeout,
                                                  &event,
                                                  &aux);
 
@@ -1247,6 +1636,8 @@ EGLint wlEglHandleImageStreamEvents(WlEglSurface *surface)
         switch (event) {
         case EGL_STREAM_IMAGE_AVAILABLE_NV:
             err = acquire_surface_image(display, surface);
+            /* Clear our timeout so we exit after all events are handled */
+            timeout = 0;
             break;
         case EGL_STREAM_IMAGE_ADD_NV:
             err = add_surface_image(display, surface);
@@ -1457,7 +1848,12 @@ static EGLint create_surface_stream_local(WlEglSurface *surface)
 
     wl_list_init(&surface->ctx.acquiredImages);
 
-    if (!surface->wlBufferEventQueue) {
+    /*
+     * Don't enable the buffer release thread when explicit sync is in use.
+     * In explicit sync we don't care about the delivery of release events, we
+     * only pay attention to the release points.
+     */
+    if (!surface->wlBufferEventQueue && !surface->wlSyncobjSurf) {
         /*
          * Local stream contexts need a private wayland queue used by a separate
          * thread that can process buffer release events even the application
@@ -1651,6 +2047,7 @@ create_surface_context(WlEglSurface *surface)
 
     /* Check whether we should use a damage thread */
     surface->ctx.useDamageThread =
+                    !surface->wlSyncobjSurf &&
                     display->devDpy->exts.stream_fifo_synchronous &&
                     display->devDpy->exts.stream_sync &&
                     data->egl.queryStream(display->devDpy->eglDisplay,
@@ -2151,6 +2548,11 @@ static EGLBoolean wlEglDestroySurface(EGLDisplay dpy, EGLSurface eglSurface)
 
     wlEglDestroyFeedback(&surface->feedback);
 
+    if (surface->wlSyncobjSurf) {
+        wp_linux_drm_syncobj_surface_v1_destroy(surface->wlSyncobjSurf);
+        wp_linux_drm_syncobj_timeline_v1_destroy(surface->wlAcquireTimeline);
+    }
+
     if (surface->presentFeedbackQueue != NULL) {
         wl_event_queue_destroy(surface->presentFeedbackQueue);
         surface->presentFeedbackQueue = NULL;
@@ -2319,6 +2721,7 @@ EGLSurface wlEglCreatePlatformWindowSurfaceHook(EGLDisplay dpy,
     surface->isSurfaceProducer = EGL_TRUE;
     surface->refCount = 1;
     surface->isDestroyed = EGL_FALSE;
+    surface->syncPoint = 1;
     // FIFO_LENGTH == 1 to set FIFO mode, FIFO_LENGTH == 0 to set MAILBOX mode
     surface->fifoLength = (display->devDpy->exts.stream_fifo_synchronous &&
                            display->devDpy->exts.stream_sync) ? 1 : 0;
@@ -2365,6 +2768,39 @@ EGLSurface wlEglCreatePlatformWindowSurfaceHook(EGLDisplay dpy,
         surface->feedback.unprocessedFeedback = false;
     }
 
+    if (display->wlDrmSyncobj) {
+        struct wp_linux_drm_syncobj_manager_v1 *wrapper;
+
+        /* Create a DRM timeline and share it with the compositor */
+        if (drmSyncobjCreate(display->drmFd, 0, &surface->drmSyncobjHandle)) {
+            err = EGL_BAD_ALLOC;
+            goto fail;
+        }
+
+        if (drmSyncobjHandleToFD(display->drmFd, surface->drmSyncobjHandle,
+                                 &surface->drmSyncobjFd)) {
+            err = EGL_BAD_ALLOC;
+            goto fail;
+        }
+
+        /* Get a per-surface explicit sync object, share our DRM syncobj with the compositor */
+        wrapper = wl_proxy_create_wrapper(display->wlDrmSyncobj);
+        wl_proxy_set_queue((struct wl_proxy *)wrapper, surface->wlEventQueue);
+
+        surface->wlSyncobjSurf =
+            wp_linux_drm_syncobj_manager_v1_get_surface(wrapper, surface->wlSurface);
+
+        surface->wlAcquireTimeline =
+            wp_linux_drm_syncobj_manager_v1_import_timeline(wrapper, surface->drmSyncobjFd);
+
+        wl_proxy_wrapper_destroy(wrapper);
+
+        if (!surface->wlSyncobjSurf || !surface->wlAcquireTimeline) {
+            err = EGL_BAD_ALLOC;
+            goto fail;
+        }
+    }
+
     err = create_surface_context(surface);
     if (err != EGL_SUCCESS) {
         goto fail;
@@ -2391,6 +2827,14 @@ EGLSurface wlEglCreatePlatformWindowSurfaceHook(EGLDisplay dpy,
     return surface;
 
 fail:
+    if (surface->drmSyncobjHandle) {
+        drmSyncobjDestroy(display->drmFd, surface->drmSyncobjHandle);
+    }
+
+    if (surface->drmSyncobjFd > 0) {
+        close(surface->drmSyncobjFd);
+    }
+
     if (surface) {
         wlEglDestroySurface(display, surface);
     }
diff --git a/src/wayland-eglswap.c b/src/wayland-eglswap.c
index a048815..bf1157d 100644
--- a/src/wayland-eglswap.c
+++ b/src/wayland-eglswap.c
@@ -148,6 +148,7 @@ EGLBoolean wlEglSwapBuffersWithDamageHook(EGLDisplay eglDisplay, EGLSurface eglS
         } else {
             wlEglCreateFrameSync(surface);
             res = wlEglSendDamageEvent(surface, surface->wlEventQueue);
+            wlEglSurfaceCheckReleasePoints(display, surface);
         }
     }
 
